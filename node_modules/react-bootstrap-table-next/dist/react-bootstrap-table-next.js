(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactBootstrapTable2"] = factory(require("react"));
	else
		root["ReactBootstrapTable2"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(10)();
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  SORT_ASC: 'asc',
  SORT_DESC: 'desc',
  ROW_SELECT_SINGLE: 'radio',
  ROW_SELECT_MULTIPLE: 'checkbox',
  ROW_SELECT_DISABLED: 'ROW_SELECT_DISABLED',
  CHECKBOX_STATUS_CHECKED: 'checked',
  CHECKBOX_STATUS_INDETERMINATE: 'indeterminate',
  CHECKBOX_STATUS_UNCHECKED: 'unchecked'
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint no-empty: 0 */
/* eslint no-param-reassign: 0 */
/* eslint prefer-rest-params: 0 */

function splitNested(str) {
  return [str].join('.').replace(/\[/g, '.').replace(/\]/g, '').split('.');
}

function get(target, field) {
  var pathArray = splitNested(field);
  var result = void 0;
  try {
    result = pathArray.reduce(function (curr, path) {
      return curr[path];
    }, target);
  } catch (e) {}
  return result;
}

function set(target, field, value) {
  var safe = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var pathArray = splitNested(field);
  var level = 0;
  pathArray.reduce(function (a, b) {
    level += 1;
    if (typeof a[b] === 'undefined') {
      if (!safe) throw new Error(a + '.' + b + ' is undefined');
      a[b] = {};
      return a[b];
    }

    if (level === pathArray.length) {
      a[b] = value;
      return value;
    }
    return a[b];
  }, target);
}

function isFunction(obj) {
  return obj && typeof obj === 'function';
}

/**
 * Checks if `value` is the Object. the `Object` except `Function` and `Array.`
 *
 * @param {*} obj - The value gonna check
 */
function isObject(obj) {
  var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  return obj !== null && type === 'object' && obj.constructor === Object;
}

function isEmptyObject(obj) {
  if (!isObject(obj)) return false;

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i += 1) {
    if (hasOwnProperty.call(obj, keys[i])) return false;
  }

  return true;
}

function isDefined(value) {
  return typeof value !== 'undefined' && value !== null;
}

function sleep(fn, ms) {
  return setTimeout(function () {
    return fn();
  }, ms);
}

function debounce(func, wait, immediate) {
  var _this = this,
      _arguments = arguments;

  var timeout = void 0;

  return function () {
    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(_this, _arguments);
      }
    };

    var callNow = immediate && !timeout;

    clearTimeout(timeout);
    timeout = setTimeout(later, wait || 0);

    if (callNow) {
      func.appy(_this, _arguments);
    }
  };
}

exports.default = {
  get: get,
  set: set,
  isFunction: isFunction,
  isObject: isObject,
  isEmptyObject: isEmptyObject,
  isDefined: isDefined,
  sleep: sleep,
  debounce: debounce
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var matchRow = exports.matchRow = function matchRow(keyField, id) {
  return function (row) {
    return row[keyField] === id;
  };
};

var getRowByRowId = exports.getRowByRowId = function getRowByRowId(_ref) {
  var data = _ref.data,
      keyField = _ref.keyField;
  return function (id) {
    return data.find(matchRow(keyField, id));
  };
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelectedRows = exports.unSelectableKeys = exports.selectableKeys = exports.isAnySelectedRow = exports.isSelectedAll = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _rows = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isSelectedAll = exports.isSelectedAll = function isSelectedAll(_ref) {
  var data = _ref.data,
      selected = _ref.selected;
  return data.length === selected.length;
};

var isAnySelectedRow = exports.isAnySelectedRow = function isAnySelectedRow(_ref2) {
  var selected = _ref2.selected;
  return function () {
    var skips = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (skips.length === 0) {
      return selected.length > 0;
    }
    return selected.filter(function (x) {
      return !skips.includes(x);
    }).length;
  };
};

var selectableKeys = exports.selectableKeys = function selectableKeys(_ref3) {
  var data = _ref3.data,
      keyField = _ref3.keyField;
  return function () {
    var skips = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (skips.length === 0) {
      return data.map(function (row) {
        return _utils2.default.get(row, keyField);
      });
    }
    return data.filter(function (row) {
      return !skips.includes(_utils2.default.get(row, keyField));
    }).map(function (row) {
      return _utils2.default.get(row, keyField);
    });
  };
};

var unSelectableKeys = exports.unSelectableKeys = function unSelectableKeys(_ref4) {
  var selected = _ref4.selected;
  return function () {
    var skips = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (skips.length === 0) {
      return [];
    }
    return selected.filter(function (x) {
      return skips.includes(x);
    });
  };
};

var getSelectedRows = exports.getSelectedRows = function getSelectedRows(store) {
  var getRow = (0, _rows.getRowByRowId)(store);
  return store.selected.map(function (k) {
    return getRow(k);
  });
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(RemoteResolver, _ExtendBase);

    function RemoteResolver() {
      _classCallCheck(this, RemoteResolver);

      return _possibleConstructorReturn(this, (RemoteResolver.__proto__ || Object.getPrototypeOf(RemoteResolver)).apply(this, arguments));
    }

    _createClass(RemoteResolver, [{
      key: 'getNewestState',
      value: function getNewestState() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var store = this.store || this.props.store;
        return _extends({
          page: store.page,
          sizePerPage: store.sizePerPage,
          filters: store.filters,
          sortField: store.sortField,
          sortOrder: store.sortOrder,
          data: store.getAllData()
        }, state);
      }
    }, {
      key: 'isRemotePagination',
      value: function isRemotePagination() {
        var remote = this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.pagination;
      }
    }, {
      key: 'isRemoteFiltering',
      value: function isRemoteFiltering() {
        var remote = this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.filter;
      }
    }, {
      key: 'isRemoteSort',
      value: function isRemoteSort() {
        var remote = this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.sort;
      }
    }, {
      key: 'isRemoteCellEdit',
      value: function isRemoteCellEdit() {
        var remote = this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.cellEdit;
      }
    }, {
      key: 'handleRemotePageChange',
      value: function handleRemotePageChange() {
        this.props.onTableChange('pagination', this.getNewestState());
      }
    }, {
      key: 'handleRemoteFilterChange',
      value: function handleRemoteFilterChange() {
        var newState = {};
        if (this.isRemotePagination()) {
          var options = this.props.pagination.options || {};
          newState.page = _utils2.default.isDefined(options.pageStartIndex) ? options.pageStartIndex : 1;
        }
        this.props.onTableChange('filter', this.getNewestState(newState));
      }
    }, {
      key: 'handleSortChange',
      value: function handleSortChange() {
        this.props.onTableChange('sort', this.getNewestState());
      }
    }, {
      key: 'handleCellChange',
      value: function handleCellChange(rowId, dataField, newValue) {
        var cellEdit = { rowId: rowId, dataField: dataField, newValue: newValue };
        this.props.onTableChange('cellEdit', this.getNewestState({ cellEdit: cellEdit }));
      }
    }]);

    return RemoteResolver;
  }(ExtendBase);
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bootstrapTable = __webpack_require__(9);

var _bootstrapTable2 = _interopRequireDefault(_bootstrapTable);

var _container = __webpack_require__(28);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _container2.default)(_bootstrapTable2.default);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _header = __webpack_require__(14);

var _header2 = _interopRequireDefault(_header);

var _caption = __webpack_require__(19);

var _caption2 = _interopRequireDefault(_caption);

var _body = __webpack_require__(20);

var _body2 = _interopRequireDefault(_body);

var _propsResolver = __webpack_require__(26);

var _propsResolver2 = _interopRequireDefault(_propsResolver);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _selection = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint arrow-body-style: 0 */

var BootstrapTable = function (_PropsBaseResolver) {
  _inherits(BootstrapTable, _PropsBaseResolver);

  function BootstrapTable(props) {
    _classCallCheck(this, BootstrapTable);

    var _this = _possibleConstructorReturn(this, (BootstrapTable.__proto__ || Object.getPrototypeOf(BootstrapTable)).call(this, props));

    _this.validateProps();

    _this.state = {
      data: props.data
    };
    return _this;
  }

  _createClass(BootstrapTable, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setState({
        data: nextProps.data
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          loading = _props.loading,
          overlay = _props.overlay;

      if (overlay) {
        var LoadingOverlay = overlay(loading);
        return _react2.default.createElement(
          LoadingOverlay,
          null,
          this.renderTable()
        );
      }
      return this.renderTable();
    }
  }, {
    key: 'renderTable',
    value: function renderTable() {
      var _props2 = this.props,
          store = _props2.store,
          columns = _props2.columns,
          keyField = _props2.keyField,
          id = _props2.id,
          classes = _props2.classes,
          striped = _props2.striped,
          hover = _props2.hover,
          bordered = _props2.bordered,
          condensed = _props2.condensed,
          noDataIndication = _props2.noDataIndication,
          caption = _props2.caption,
          rowStyle = _props2.rowStyle,
          rowClasses = _props2.rowClasses,
          wrapperClasses = _props2.wrapperClasses,
          rowEvents = _props2.rowEvents;


      var tableWrapperClass = (0, _classnames2.default)('react-bootstrap-table', wrapperClasses);

      var tableClass = (0, _classnames2.default)('table', {
        'table-striped': striped,
        'table-hover': hover,
        'table-bordered': bordered,
        'table-condensed': condensed
      }, classes);

      var cellSelectionInfo = this.resolveSelectRowProps({
        onRowSelect: this.props.onRowSelect
      });

      var headerCellSelectionInfo = this.resolveSelectRowPropsForHeader({
        onAllRowsSelect: this.props.onAllRowsSelect,
        selected: store.selected,
        allRowsSelected: (0, _selection.isSelectedAll)(store)
      });

      var tableCaption = caption && _react2.default.createElement(
        _caption2.default,
        null,
        caption
      );

      return _react2.default.createElement(
        'div',
        { className: tableWrapperClass },
        _react2.default.createElement(
          'table',
          { id: id, className: tableClass },
          tableCaption,
          _react2.default.createElement(_header2.default, {
            columns: columns,
            sortField: store.sortField,
            sortOrder: store.sortOrder,
            onSort: this.props.onSort,
            onFilter: this.props.onFilter,
            onExternalFilter: this.props.onExternalFilter,
            selectRow: headerCellSelectionInfo
          }),
          _react2.default.createElement(_body2.default, {
            data: this.state.data,
            keyField: keyField,
            columns: columns,
            isEmpty: this.isEmpty(),
            visibleColumnSize: this.visibleColumnSize(),
            noDataIndication: noDataIndication,
            cellEdit: this.props.cellEdit || {},
            selectRow: cellSelectionInfo,
            selectedRowKeys: store.selected,
            rowStyle: rowStyle,
            rowClasses: rowClasses,
            rowEvents: rowEvents
          })
        )
      );
    }
  }]);

  return BootstrapTable;
}((0, _propsResolver2.default)(_react.Component));

BootstrapTable.propTypes = {
  keyField: _propTypes2.default.string.isRequired,
  data: _propTypes2.default.array.isRequired,
  columns: _propTypes2.default.array.isRequired,
  remote: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.shape({
    pagination: _propTypes2.default.bool
  })]),
  store: _propTypes2.default.object,
  noDataIndication: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  striped: _propTypes2.default.bool,
  bordered: _propTypes2.default.bool,
  hover: _propTypes2.default.bool,
  id: _propTypes2.default.string,
  classes: _propTypes2.default.string,
  wrapperClasses: _propTypes2.default.string,
  condensed: _propTypes2.default.bool,
  caption: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string]),
  pagination: _propTypes2.default.object,
  filter: _propTypes2.default.object,
  cellEdit: _propTypes2.default.object,
  selectRow: _propTypes2.default.shape({
    mode: _propTypes2.default.oneOf([_const2.default.ROW_SELECT_SINGLE, _const2.default.ROW_SELECT_MULTIPLE]).isRequired,
    clickToSelect: _propTypes2.default.bool,
    clickToEdit: _propTypes2.default.bool,
    onSelect: _propTypes2.default.func,
    onSelectAll: _propTypes2.default.func,
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    classes: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    nonSelectable: _propTypes2.default.array,
    bgColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    hideSelectColumn: _propTypes2.default.bool,
    selectionRenderer: _propTypes2.default.func,
    selectionHeaderRenderer: _propTypes2.default.func
  }),
  onRowSelect: _propTypes2.default.func,
  onAllRowsSelect: _propTypes2.default.func,
  rowStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
  rowEvents: _propTypes2.default.object,
  rowClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  defaultSorted: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    dataField: _propTypes2.default.string.isRequired,
    order: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]).isRequired
  })),
  defaultSortDirection: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]),
  overlay: _propTypes2.default.func,
  onTableChange: _propTypes2.default.func,
  onSort: _propTypes2.default.func,
  onFilter: _propTypes2.default.func,
  onExternalFilter: _propTypes2.default.func
};

BootstrapTable.defaultProps = {
  remote: false,
  striped: false,
  bordered: true,
  hover: false,
  condensed: false,
  noDataIndication: null
};

exports.default = BootstrapTable;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(11);
var invariant = __webpack_require__(12);
var ReactPropTypesSecret = __webpack_require__(13);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _headerCell = __webpack_require__(15);

var _headerCell2 = _interopRequireDefault(_headerCell);

var _selectionHeaderCell = __webpack_require__(18);

var _selectionHeaderCell2 = _interopRequireDefault(_selectionHeaderCell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Header = function Header(props) {
  var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED;
  var columns = props.columns,
      onSort = props.onSort,
      onFilter = props.onFilter,
      sortField = props.sortField,
      sortOrder = props.sortOrder,
      selectRow = props.selectRow,
      onExternalFilter = props.onExternalFilter;


  return _react2.default.createElement(
    'thead',
    null,
    _react2.default.createElement(
      'tr',
      null,
      selectRow.mode !== ROW_SELECT_DISABLED && !selectRow.hideSelectColumn ? _react2.default.createElement(_selectionHeaderCell2.default, selectRow) : null,
      columns.map(function (column, i) {
        if (!column.hidden) {
          var currSort = column.dataField === sortField;
          var isLastSorting = column.dataField === sortField;

          return _react2.default.createElement(_headerCell2.default, {
            index: i,
            key: column.dataField,
            column: column,
            onSort: onSort,
            sorting: currSort,
            onFilter: onFilter,
            onExternalFilter: onExternalFilter,
            sortOrder: sortOrder,
            isLastSorting: isLastSorting
          });
        }
        return false;
      })
    )
  );
}; /* eslint react/require-default-props: 0 */


Header.propTypes = {
  columns: _propTypes2.default.array.isRequired,
  onSort: _propTypes2.default.func,
  onFilter: _propTypes2.default.func,
  sortField: _propTypes2.default.string,
  sortOrder: _propTypes2.default.string,
  selectRow: _propTypes2.default.object,
  onExternalFilter: _propTypes2.default.func
};

exports.default = Header;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint react/require-default-props: 0 */


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _symbol = __webpack_require__(16);

var _symbol2 = _interopRequireDefault(_symbol);

var _caret = __webpack_require__(17);

var _caret2 = _interopRequireDefault(_caret);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HeaderCell = function HeaderCell(props) {
  var column = props.column,
      index = props.index,
      onSort = props.onSort,
      sorting = props.sorting,
      sortOrder = props.sortOrder,
      isLastSorting = props.isLastSorting,
      onFilter = props.onFilter,
      onExternalFilter = props.onExternalFilter;
  var text = column.text,
      sort = column.sort,
      filter = column.filter,
      filterRenderer = column.filterRenderer,
      headerTitle = column.headerTitle,
      headerAlign = column.headerAlign,
      headerFormatter = column.headerFormatter,
      headerEvents = column.headerEvents,
      headerClasses = column.headerClasses,
      headerStyle = column.headerStyle,
      headerAttrs = column.headerAttrs,
      headerSortingClasses = column.headerSortingClasses,
      headerSortingStyle = column.headerSortingStyle;


  var cellAttrs = _extends({}, _utils2.default.isFunction(headerAttrs) ? headerAttrs(column, index) : headerAttrs, headerEvents);

  var sortSymbol = void 0;
  var filterElm = void 0;
  var cellStyle = {};
  var cellClasses = _utils2.default.isFunction(headerClasses) ? headerClasses(column, index) : headerClasses;

  if (headerStyle) {
    cellStyle = _utils2.default.isFunction(headerStyle) ? headerStyle(column, index) : headerStyle;
  }

  if (headerTitle) {
    cellAttrs.title = _utils2.default.isFunction(headerTitle) ? headerTitle(column, index) : text;
  }

  if (headerAlign) {
    cellStyle.textAlign = _utils2.default.isFunction(headerAlign) ? headerAlign(column, index) : headerAlign;
  }

  if (sort) {
    var customClick = cellAttrs.onClick;
    cellAttrs.onClick = function (e) {
      onSort(column);
      if (_utils2.default.isFunction(customClick)) customClick(e);
    };
    cellAttrs.className = (0, _classnames2.default)(cellAttrs.className, 'sortable');

    if (sorting) {
      sortSymbol = _react2.default.createElement(_caret2.default, { order: sortOrder });

      // append customized classes or style if table was sorting based on the current column.
      cellClasses = (0, _classnames2.default)(cellClasses, _utils2.default.isFunction(headerSortingClasses) ? headerSortingClasses(column, sortOrder, isLastSorting, index) : headerSortingClasses);

      cellStyle = _extends({}, cellStyle, _utils2.default.isFunction(headerSortingStyle) ? headerSortingStyle(column, sortOrder, isLastSorting, index) : headerSortingStyle);
    } else {
      sortSymbol = _react2.default.createElement(_symbol2.default, null);
    }
  }

  if (cellClasses) cellAttrs.className = (0, _classnames2.default)(cellAttrs.className, cellClasses);
  if (!_utils2.default.isEmptyObject(cellStyle)) cellAttrs.style = cellStyle;

  if (filterRenderer) {
    var onCustomFilter = onExternalFilter(column, filter.props.type);
    filterElm = filterRenderer(onCustomFilter, column);
  } else if (filter) {
    filterElm = _react2.default.createElement(filter.Filter, _extends({}, filter.props, { onFilter: onFilter, column: column }));
  }

  var children = headerFormatter ? headerFormatter(column, index, { sortElement: sortSymbol, filterElement: filterElm }) : text;

  if (headerFormatter) {
    return _react2.default.createElement('th', cellAttrs, children);
  }

  return _react2.default.createElement('th', cellAttrs, children, sortSymbol, filterElm);
};

HeaderCell.propTypes = {
  column: _propTypes2.default.shape({
    dataField: _propTypes2.default.string.isRequired,
    text: _propTypes2.default.string.isRequired,
    hidden: _propTypes2.default.bool,
    headerFormatter: _propTypes2.default.func,
    formatter: _propTypes2.default.func,
    formatExtraData: _propTypes2.default.any,
    headerClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    classes: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    headerStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    headerTitle: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    title: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    headerEvents: _propTypes2.default.object,
    events: _propTypes2.default.object,
    headerAlign: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    headerAttrs: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    attrs: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    sort: _propTypes2.default.bool,
    sortFunc: _propTypes2.default.func,
    onSort: _propTypes2.default.func,
    editor: _propTypes2.default.object,
    editable: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    editCellStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    editCellClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    editorStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    editorClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    editorRenderer: _propTypes2.default.func,
    validator: _propTypes2.default.func,
    filter: _propTypes2.default.object,
    filterRenderer: _propTypes2.default.func,
    filterValue: _propTypes2.default.func
  }).isRequired,
  index: _propTypes2.default.number.isRequired,
  onSort: _propTypes2.default.func,
  sorting: _propTypes2.default.bool,
  sortOrder: _propTypes2.default.oneOf([_const2.default.SORT_ASC, _const2.default.SORT_DESC]),
  isLastSorting: _propTypes2.default.bool,
  onFilter: _propTypes2.default.func,
  onExternalFilter: _propTypes2.default.func
};

exports.default = HeaderCell;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortSymbol = function SortSymbol() {
  return _react2.default.createElement(
    "span",
    { className: "order" },
    _react2.default.createElement(
      "span",
      { className: "dropdown" },
      _react2.default.createElement("span", { className: "caret" })
    ),
    _react2.default.createElement(
      "span",
      { className: "dropup" },
      _react2.default.createElement("span", { className: "caret" })
    )
  );
};

exports.default = SortSymbol;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortCaret = function SortCaret(_ref) {
  var order = _ref.order;

  var orderClass = (0, _classnames2.default)('react-bootstrap-table-sort-order', {
    dropup: order === _const2.default.SORT_ASC
  });
  return _react2.default.createElement(
    'span',
    { className: orderClass },
    _react2.default.createElement('span', { className: 'caret' })
  );
};

SortCaret.propTypes = {
  order: _propTypes2.default.oneOf([_const2.default.SORT_ASC, _const2.default.SORT_DESC]).isRequired
};
exports.default = SortCaret;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CheckBox = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */


var CheckBox = exports.CheckBox = function CheckBox(_ref) {
  var checked = _ref.checked,
      indeterminate = _ref.indeterminate;
  return _react2.default.createElement('input', {
    type: 'checkbox',
    checked: checked,
    ref: function ref(input) {
      if (input) input.indeterminate = indeterminate; // eslint-disable-line no-param-reassign
    }
  });
};

CheckBox.propTypes = {
  checked: _propTypes2.default.bool.isRequired,
  indeterminate: _propTypes2.default.bool.isRequired
};

var SelectionHeaderCell = function (_Component) {
  _inherits(SelectionHeaderCell, _Component);

  function SelectionHeaderCell() {
    _classCallCheck(this, SelectionHeaderCell);

    var _this = _possibleConstructorReturn(this, (SelectionHeaderCell.__proto__ || Object.getPrototypeOf(SelectionHeaderCell)).call(this));

    _this.handleCheckBoxClick = _this.handleCheckBoxClick.bind(_this);
    return _this;
  }

  /**
   * avoid updating if button is
   * 1. radio
   * 2. status was not changed.
   */


  _createClass(SelectionHeaderCell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;
      var _props = this.props,
          mode = _props.mode,
          checkedStatus = _props.checkedStatus;


      if (mode === ROW_SELECT_SINGLE) return false;

      return nextProps.checkedStatus !== checkedStatus;
    }
  }, {
    key: 'handleCheckBoxClick',
    value: function handleCheckBoxClick(e) {
      var onAllRowsSelect = this.props.onAllRowsSelect;


      onAllRowsSelect(e);
    }
  }, {
    key: 'render',
    value: function render() {
      var CHECKBOX_STATUS_CHECKED = _const2.default.CHECKBOX_STATUS_CHECKED,
          CHECKBOX_STATUS_INDETERMINATE = _const2.default.CHECKBOX_STATUS_INDETERMINATE,
          ROW_SELECT_MULTIPLE = _const2.default.ROW_SELECT_MULTIPLE;
      var _props2 = this.props,
          mode = _props2.mode,
          checkedStatus = _props2.checkedStatus,
          selectionHeaderRenderer = _props2.selectionHeaderRenderer;


      var checked = checkedStatus === CHECKBOX_STATUS_CHECKED;

      var indeterminate = checkedStatus === CHECKBOX_STATUS_INDETERMINATE;

      var attrs = {};
      var content = void 0;
      if (selectionHeaderRenderer) {
        content = selectionHeaderRenderer({
          mode: mode,
          checked: checked,
          indeterminate: indeterminate
        });
        attrs.onClick = this.handleCheckBoxClick;
      } else if (mode === ROW_SELECT_MULTIPLE) {
        content = _react2.default.createElement(CheckBox, _extends({}, this.props, {
          checked: checked,
          indeterminate: indeterminate
        }));
        attrs.onClick = this.handleCheckBoxClick;
      }

      return _react2.default.createElement(
        'th',
        _extends({ 'data-row-selection': true }, attrs),
        content
      );
    }
  }]);

  return SelectionHeaderCell;
}(_react.Component);

SelectionHeaderCell.propTypes = {
  mode: _propTypes2.default.string.isRequired,
  checkedStatus: _propTypes2.default.string,
  onAllRowsSelect: _propTypes2.default.func,
  selectionHeaderRenderer: _propTypes2.default.func
};
exports.default = SelectionHeaderCell;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint react/require-default-props: 0 */
var Caption = function Caption(props) {
  if (!props.children) return null;
  return _react2.default.createElement(
    'caption',
    null,
    props.children
  );
};

Caption.propTypes = {
  children: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string])
};

exports.default = Caption;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint react/prop-types: 0 */
/* eslint react/require-default-props: 0 */

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _row = __webpack_require__(21);

var _row2 = _interopRequireDefault(_row);

var _rowSection = __webpack_require__(25);

var _rowSection2 = _interopRequireDefault(_rowSection);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Body = function Body(props) {
  var columns = props.columns,
      data = props.data,
      keyField = props.keyField,
      isEmpty = props.isEmpty,
      noDataIndication = props.noDataIndication,
      visibleColumnSize = props.visibleColumnSize,
      cellEdit = props.cellEdit,
      selectRow = props.selectRow,
      selectedRowKeys = props.selectedRowKeys,
      rowStyle = props.rowStyle,
      rowClasses = props.rowClasses,
      rowEvents = props.rowEvents;
  var bgColor = selectRow.bgColor,
      nonSelectable = selectRow.nonSelectable;


  var content = void 0;

  if (isEmpty) {
    var indication = _utils2.default.isFunction(noDataIndication) ? noDataIndication() : noDataIndication;
    if (!indication) {
      return null;
    }
    content = _react2.default.createElement(_rowSection2.default, { content: indication, colSpan: visibleColumnSize });
  } else {
    var nonEditableRows = cellEdit.nonEditableRows || [];
    content = data.map(function (row, index) {
      var key = _utils2.default.get(row, keyField);
      var editable = !(nonEditableRows.length > 0 && nonEditableRows.indexOf(key) > -1);

      var selected = selectRow.mode !== _const2.default.ROW_SELECT_DISABLED ? selectedRowKeys.includes(key) : null;

      var attrs = rowEvents || {};
      var style = _utils2.default.isFunction(rowStyle) ? rowStyle(row, index) : rowStyle;
      var classes = _utils2.default.isFunction(rowClasses) ? rowClasses(row, index) : rowClasses;
      if (selected) {
        var selectedStyle = _utils2.default.isFunction(selectRow.style) ? selectRow.style(row, index) : selectRow.style;

        var selectedClasses = _utils2.default.isFunction(selectRow.classes) ? selectRow.classes(row, index) : selectRow.classes;

        style = _extends({}, style, selectedStyle);
        classes = (0, _classnames2.default)(classes, selectedClasses);

        if (bgColor) {
          style = style || {};
          style.backgroundColor = _utils2.default.isFunction(bgColor) ? bgColor(row, index) : bgColor;
        }
      }

      var selectable = !nonSelectable || !nonSelectable.includes(key);

      return _react2.default.createElement(_row2.default, {
        key: key,
        row: row,
        keyField: keyField,
        rowIndex: index,
        columns: columns,
        cellEdit: cellEdit,
        editable: editable,
        selectable: selectable,
        selected: selected,
        selectRow: selectRow,
        style: style,
        className: classes,
        attrs: attrs
      });
    });
  }

  return _react2.default.createElement(
    'tbody',
    null,
    content
  );
};

Body.propTypes = {
  keyField: _propTypes2.default.string.isRequired,
  data: _propTypes2.default.array.isRequired,
  columns: _propTypes2.default.array.isRequired,
  selectRow: _propTypes2.default.object,
  selectedRowKeys: _propTypes2.default.array
};

exports.default = Body;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _cell = __webpack_require__(22);

var _cell2 = _interopRequireDefault(_cell);

var _selectionCell = __webpack_require__(23);

var _selectionCell2 = _interopRequireDefault(_selectionCell);

var _rowEventDelegater = __webpack_require__(24);

var _rowEventDelegater2 = _interopRequireDefault(_rowEventDelegater);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */
/* eslint react/no-array-index-key: 0 */


var Row = function (_eventDelegater) {
  _inherits(Row, _eventDelegater);

  function Row() {
    _classCallCheck(this, Row);

    return _possibleConstructorReturn(this, (Row.__proto__ || Object.getPrototypeOf(Row)).apply(this, arguments));
  }

  _createClass(Row, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          row = _props.row,
          columns = _props.columns,
          keyField = _props.keyField,
          rowIndex = _props.rowIndex,
          className = _props.className,
          style = _props.style,
          attrs = _props.attrs,
          cellEdit = _props.cellEdit,
          selected = _props.selected,
          selectRow = _props.selectRow,
          selectable = _props.selectable,
          editableRow = _props.editable;

      var mode = cellEdit.mode,
          onStart = cellEdit.onStart,
          EditingCell = cellEdit.EditingCell,
          editingRowIdx = cellEdit.ridx,
          editingColIdx = cellEdit.cidx,
          CLICK_TO_CELL_EDIT = cellEdit.CLICK_TO_CELL_EDIT,
          DBCLICK_TO_CELL_EDIT = cellEdit.DBCLICK_TO_CELL_EDIT,
          rest = _objectWithoutProperties(cellEdit, ['mode', 'onStart', 'EditingCell', 'ridx', 'cidx', 'CLICK_TO_CELL_EDIT', 'DBCLICK_TO_CELL_EDIT']);

      var key = _utils2.default.get(row, keyField);
      var hideSelectColumn = selectRow.hideSelectColumn;

      var trAttrs = this.delegate(attrs);

      return _react2.default.createElement(
        'tr',
        _extends({ style: style, className: className }, trAttrs),
        selectRow.mode !== _const2.default.ROW_SELECT_DISABLED && !hideSelectColumn ? _react2.default.createElement(_selectionCell2.default, _extends({}, selectRow, {
          rowKey: key,
          rowIndex: rowIndex,
          selected: selected,
          disabled: !selectable
        })) : null,
        columns.map(function (column, index) {
          if (!column.hidden) {
            var dataField = column.dataField;

            var content = _utils2.default.get(row, dataField);
            var editable = _utils2.default.isDefined(column.editable) ? column.editable : true;
            if (dataField === keyField || !editableRow) editable = false;
            if (_utils2.default.isFunction(column.editable)) {
              editable = column.editable(content, row, rowIndex, index);
            }
            if (rowIndex === editingRowIdx && index === editingColIdx) {
              var editCellstyle = column.editCellStyle || {};
              var editCellclasses = column.editCellClasses;
              if (_utils2.default.isFunction(column.editCellStyle)) {
                editCellstyle = column.editCellStyle(content, row, rowIndex, index);
              }
              if (_utils2.default.isFunction(column.editCellClasses)) {
                editCellclasses = column.editCellClasses(content, row, rowIndex, index);
              }
              return _react2.default.createElement(EditingCell, _extends({
                key: content + '-' + index,
                row: row,
                rowIndex: rowIndex,
                column: column,
                columnIndex: index,
                className: editCellclasses,
                style: editCellstyle
              }, rest));
            }
            return _react2.default.createElement(_cell2.default, {
              key: content + '-' + index,
              row: row,
              rowIndex: rowIndex,
              columnIndex: index,
              column: column,
              onStart: onStart,
              editable: editable,
              clickToEdit: mode === CLICK_TO_CELL_EDIT,
              dbclickToEdit: mode === DBCLICK_TO_CELL_EDIT
            });
          }
          return false;
        })
      );
    }
  }]);

  return Row;
}((0, _rowEventDelegater2.default)(_react.Component));

Row.propTypes = {
  row: _propTypes2.default.object.isRequired,
  rowIndex: _propTypes2.default.number.isRequired,
  columns: _propTypes2.default.array.isRequired,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  attrs: _propTypes2.default.object
};

Row.defaultProps = {
  editable: true,
  style: {},
  className: null,
  attrs: {}
};

exports.default = Row;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


var Cell = function (_Component) {
  _inherits(Cell, _Component);

  function Cell(props) {
    _classCallCheck(this, Cell);

    var _this = _possibleConstructorReturn(this, (Cell.__proto__ || Object.getPrototypeOf(Cell)).call(this, props));

    _this.handleEditingCell = _this.handleEditingCell.bind(_this);
    return _this;
  }

  _createClass(Cell, [{
    key: 'handleEditingCell',
    value: function handleEditingCell(e) {
      var _props = this.props,
          column = _props.column,
          onStart = _props.onStart,
          rowIndex = _props.rowIndex,
          columnIndex = _props.columnIndex,
          clickToEdit = _props.clickToEdit,
          dbclickToEdit = _props.dbclickToEdit;
      var events = column.events;

      if (events) {
        if (clickToEdit) {
          var customClick = events.onClick;
          if (_utils2.default.isFunction(customClick)) customClick(e);
        } else if (dbclickToEdit) {
          var customDbClick = events.onDoubleClick;
          if (_utils2.default.isFunction(customDbClick)) customDbClick(e);
        }
      }
      if (onStart) {
        onStart(rowIndex, columnIndex);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          row = _props2.row,
          rowIndex = _props2.rowIndex,
          column = _props2.column,
          columnIndex = _props2.columnIndex,
          editable = _props2.editable,
          clickToEdit = _props2.clickToEdit,
          dbclickToEdit = _props2.dbclickToEdit;
      var dataField = column.dataField,
          formatter = column.formatter,
          formatExtraData = column.formatExtraData,
          style = column.style,
          classes = column.classes,
          title = column.title,
          events = column.events,
          align = column.align,
          attrs = column.attrs;

      var cellTitle = void 0;
      var cellStyle = {};
      var content = _utils2.default.get(row, dataField);

      var cellAttrs = _extends({}, _utils2.default.isFunction(attrs) ? attrs(content, row, rowIndex, columnIndex) : attrs, events);

      var cellClasses = _utils2.default.isFunction(classes) ? classes(content, row, rowIndex, columnIndex) : classes;

      if (style) {
        cellStyle = _utils2.default.isFunction(style) ? style(content, row, rowIndex, columnIndex) : style;
      }

      if (title) {
        cellTitle = _utils2.default.isFunction(title) ? title(content, row, rowIndex, columnIndex) : content;
        cellAttrs.title = cellTitle;
      }

      if (formatter) {
        content = column.formatter(content, row, rowIndex, formatExtraData);
      }

      if (align) {
        cellStyle.textAlign = _utils2.default.isFunction(align) ? align(content, row, rowIndex, columnIndex) : align;
      }

      if (cellClasses) cellAttrs.className = cellClasses;

      if (!_utils2.default.isEmptyObject(cellStyle)) cellAttrs.style = cellStyle;
      if (clickToEdit && editable) {
        cellAttrs.onClick = this.handleEditingCell;
      } else if (dbclickToEdit && editable) {
        cellAttrs.onDoubleClick = this.handleEditingCell;
      }
      return _react2.default.createElement(
        'td',
        cellAttrs,
        typeof content === 'boolean' ? '' + content : content
      );
    }
  }]);

  return Cell;
}(_react.Component);

Cell.propTypes = {
  row: _propTypes2.default.object.isRequired,
  rowIndex: _propTypes2.default.number.isRequired,
  column: _propTypes2.default.object.isRequired,
  columnIndex: _propTypes2.default.number.isRequired
};

exports.default = Cell;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 react/require-default-props: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 jsx-a11y/no-noninteractive-element-interactions: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */


var SelectionCell = function (_Component) {
  _inherits(SelectionCell, _Component);

  function SelectionCell() {
    _classCallCheck(this, SelectionCell);

    var _this = _possibleConstructorReturn(this, (SelectionCell.__proto__ || Object.getPrototypeOf(SelectionCell)).call(this));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(SelectionCell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var selected = this.props.selected;


      return nextProps.selected !== selected;
    }
  }, {
    key: 'handleClick',
    value: function handleClick(e) {
      var _props = this.props,
          inputType = _props.mode,
          rowKey = _props.rowKey,
          selected = _props.selected,
          onRowSelect = _props.onRowSelect,
          disabled = _props.disabled,
          rowIndex = _props.rowIndex,
          clickToSelect = _props.clickToSelect;


      if (disabled) return;
      if (clickToSelect) return;

      var checked = inputType === _const2.default.ROW_SELECT_SINGLE ? true : !selected;

      onRowSelect(rowKey, checked, rowIndex, e);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          inputType = _props2.mode,
          selected = _props2.selected,
          disabled = _props2.disabled,
          selectionRenderer = _props2.selectionRenderer;


      return _react2.default.createElement(
        'td',
        { onClick: this.handleClick },
        selectionRenderer ? selectionRenderer({
          mode: inputType,
          checked: selected,
          disabled: disabled
        }) : _react2.default.createElement('input', {
          type: inputType,
          checked: selected,
          disabled: disabled
        })
      );
    }
  }]);

  return SelectionCell;
}(_react.Component);

SelectionCell.propTypes = {
  mode: _propTypes2.default.string.isRequired,
  rowKey: _propTypes2.default.any,
  selected: _propTypes2.default.bool,
  onRowSelect: _propTypes2.default.func,
  disabled: _propTypes2.default.bool,
  rowIndex: _propTypes2.default.number,
  clickToSelect: _propTypes2.default.bool,
  selectionRenderer: _propTypes2.default.func
};
exports.default = SelectionCell;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var events = ['onClick', 'onDoubleClick', 'onMouseEnter', 'onMouseLeave'];

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(RowEventDelegater, _ExtendBase);

    function RowEventDelegater(props) {
      _classCallCheck(this, RowEventDelegater);

      var _this = _possibleConstructorReturn(this, (RowEventDelegater.__proto__ || Object.getPrototypeOf(RowEventDelegater)).call(this, props));

      _this.clickNum = 0;
      _this.createDefaultEventHandler = _this.createDefaultEventHandler.bind(_this);
      _this.createClickEventHandler = _this.createClickEventHandler.bind(_this);
      return _this;
    }

    _createClass(RowEventDelegater, [{
      key: 'createDefaultEventHandler',
      value: function createDefaultEventHandler(cb) {
        var _this2 = this;

        return function (e) {
          var _props = _this2.props,
              row = _props.row,
              rowIndex = _props.rowIndex;

          cb(e, row, rowIndex);
        };
      }
    }, {
      key: 'createClickEventHandler',
      value: function createClickEventHandler(cb) {
        var _this3 = this;

        return function (e) {
          var _props2 = _this3.props,
              row = _props2.row,
              selected = _props2.selected,
              keyField = _props2.keyField,
              selectable = _props2.selectable,
              rowIndex = _props2.rowIndex,
              _props2$selectRow = _props2.selectRow,
              onRowSelect = _props2$selectRow.onRowSelect,
              clickToEdit = _props2$selectRow.clickToEdit,
              _props2$cellEdit = _props2.cellEdit,
              mode = _props2$cellEdit.mode,
              DBCLICK_TO_CELL_EDIT = _props2$cellEdit.DBCLICK_TO_CELL_EDIT,
              DELAY_FOR_DBCLICK = _props2$cellEdit.DELAY_FOR_DBCLICK;


          var clickFn = function clickFn() {
            if (cb) {
              cb(e, row, rowIndex);
            }
            if (selectable) {
              var key = _utils2.default.get(row, keyField);
              onRowSelect(key, !selected, rowIndex, e);
            }
          };

          if (mode === DBCLICK_TO_CELL_EDIT && clickToEdit) {
            _this3.clickNum += 1;
            _utils2.default.debounce(function () {
              if (_this3.clickNum === 1) {
                clickFn();
              }
              _this3.clickNum = 0;
            }, DELAY_FOR_DBCLICK)();
          } else {
            clickFn();
          }
        };
      }
    }, {
      key: 'delegate',
      value: function delegate() {
        var _this4 = this;

        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var newAttrs = {};
        if (this.props.selectRow && this.props.selectRow.clickToSelect) {
          newAttrs.onClick = this.createClickEventHandler(attrs.onClick);
        }
        Object.keys(attrs).forEach(function (attr) {
          if (!newAttrs[attr]) {
            if (events.includes(attr)) {
              newAttrs[attr] = _this4.createDefaultEventHandler(attrs[attr]);
            } else {
              newAttrs[attr] = attrs[attr];
            }
          }
        });
        return newAttrs;
      }
    }]);

    return RowEventDelegater;
  }(ExtendBase);
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RowSection = function RowSection(_ref) {
  var content = _ref.content,
      colSpan = _ref.colSpan;
  return _react2.default.createElement(
    'tr',
    null,
    _react2.default.createElement(
      'td',
      {
        'data-toggle': 'collapse',
        colSpan: colSpan,
        className: 'react-bs-table-no-data'
      },
      content
    )
  );
};

RowSection.propTypes = {
  content: _propTypes2.default.any,
  colSpan: _propTypes2.default.number
};

RowSection.defaultProps = {
  content: null,
  colSpan: 1
};

exports.default = RowSection;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _columnResolver = __webpack_require__(27);

var _columnResolver2 = _interopRequireDefault(_columnResolver);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ColumnResolver) {
    _inherits(TableResolver, _ColumnResolver);

    function TableResolver() {
      _classCallCheck(this, TableResolver);

      return _possibleConstructorReturn(this, (TableResolver.__proto__ || Object.getPrototypeOf(TableResolver)).apply(this, arguments));
    }

    _createClass(TableResolver, [{
      key: 'validateProps',
      value: function validateProps() {
        var keyField = this.props.keyField;

        if (!keyField) {
          throw new Error('Please specify a field as key via keyField');
        }
        if (this.visibleColumnSize(false) <= 0) {
          throw new Error('No visible columns detected');
        }
      }
    }, {
      key: 'isEmpty',
      value: function isEmpty() {
        return this.props.data.length === 0;
      }

      /**
       * props resolver for cell selection
       * @param {Object} options - addtional options like callback which are about to merge into props
       *
       * @returns {Object} result - props for cell selections
       * @returns {String} result.mode - input type of row selection or disabled.
       */

    }, {
      key: 'resolveSelectRowProps',
      value: function resolveSelectRowProps(options) {
        var selectRow = this.props.selectRow;
        var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED;


        if (_utils2.default.isDefined(selectRow)) {
          return _extends({}, selectRow, options);
        }

        return {
          mode: ROW_SELECT_DISABLED
        };
      }

      /**
       * props resolver for header cell selection
       * @param {Object} options - addtional options like callback which are about to merge into props
       *
       * @returns {Object} result - props for cell selections
       * @returns {String} result.mode - input type of row selection or disabled.
       * @returns {String} result.checkedStatus - checkbox status depending on selected rows counts
       */

    }, {
      key: 'resolveSelectRowPropsForHeader',
      value: function resolveSelectRowPropsForHeader() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var selectRow = this.props.selectRow;

        var allRowsSelected = options.allRowsSelected,
            _options$selected = options.selected,
            selected = _options$selected === undefined ? [] : _options$selected,
            rest = _objectWithoutProperties(options, ['allRowsSelected', 'selected']);

        var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED,
            CHECKBOX_STATUS_CHECKED = _const2.default.CHECKBOX_STATUS_CHECKED,
            CHECKBOX_STATUS_INDETERMINATE = _const2.default.CHECKBOX_STATUS_INDETERMINATE,
            CHECKBOX_STATUS_UNCHECKED = _const2.default.CHECKBOX_STATUS_UNCHECKED;


        if (_utils2.default.isDefined(selectRow)) {
          var checkedStatus = void 0;

          // checkbox status depending on selected rows counts
          if (allRowsSelected) checkedStatus = CHECKBOX_STATUS_CHECKED;else if (selected.length === 0) checkedStatus = CHECKBOX_STATUS_UNCHECKED;else checkedStatus = CHECKBOX_STATUS_INDETERMINATE;

          return _extends({}, selectRow, rest, {
            checkedStatus: checkedStatus
          });
        }

        return {
          mode: ROW_SELECT_DISABLED
        };
      }
    }]);

    return TableResolver;
  }((0, _columnResolver2.default)(ExtendBase));
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(ColumnResolver, _ExtendBase);

    function ColumnResolver() {
      _classCallCheck(this, ColumnResolver);

      return _possibleConstructorReturn(this, (ColumnResolver.__proto__ || Object.getPrototypeOf(ColumnResolver)).apply(this, arguments));
    }

    _createClass(ColumnResolver, [{
      key: "visibleColumnSize",
      value: function visibleColumnSize() {
        var includeSelectColumn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var columnLen = this.props.columns.filter(function (c) {
          return !c.hidden;
        }).length;
        if (!includeSelectColumn) return columnLen;
        if (this.props.selectRow && !this.props.selectRow.hideSelectColumn) {
          return columnLen + 1;
        }
        return columnLen;
      }
    }]);

    return ColumnResolver;
  }(ExtendBase);
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _store = __webpack_require__(29);

var _store2 = _interopRequireDefault(_store);

var _wrapper = __webpack_require__(31);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _wrapper3 = __webpack_require__(32);

var _wrapper4 = _interopRequireDefault(_wrapper3);

var _remoteResolver2 = __webpack_require__(7);

var _remoteResolver3 = _interopRequireDefault(_remoteResolver2);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-return-assign: 0 */
/* eslint react/prop-types: 0 */


var withDataStore = function withDataStore(Base) {
  return function (_remoteResolver) {
    _inherits(BootstrapTableContainer, _remoteResolver);

    function BootstrapTableContainer(props) {
      _classCallCheck(this, BootstrapTableContainer);

      var _this = _possibleConstructorReturn(this, (BootstrapTableContainer.__proto__ || Object.getPrototypeOf(BootstrapTableContainer)).call(this, props));

      _this.store = new _store2.default(props.keyField);
      _this.store.data = props.data;
      _this.wrapComponents();
      return _this;
    }

    _createClass(BootstrapTableContainer, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.store.setAllData(nextProps.data);
      }
    }, {
      key: 'wrapComponents',
      value: function wrapComponents() {
        this.BaseComponent = Base;
        var _props = this.props,
            pagination = _props.pagination,
            columns = _props.columns,
            filter = _props.filter,
            selectRow = _props.selectRow,
            cellEdit = _props.cellEdit;

        if (pagination) {
          var wrapperFactory = pagination.wrapperFactory;

          this.BaseComponent = wrapperFactory(this.BaseComponent, {
            remoteResolver: _remoteResolver3.default
          });
        }

        if (columns.filter(function (col) {
          return col.sort;
        }).length > 0) {
          this.BaseComponent = (0, _wrapper2.default)(this.BaseComponent);
        }

        if (filter) {
          var _wrapperFactory = filter.wrapperFactory;

          this.BaseComponent = _wrapperFactory(this.BaseComponent, {
            _: _utils2.default,
            remoteResolver: _remoteResolver3.default
          });
        }

        if (cellEdit) {
          var _wrapperFactory2 = cellEdit.wrapperFactory;

          this.BaseComponent = _wrapperFactory2(this.BaseComponent, {
            _: _utils2.default,
            remoteResolver: _remoteResolver3.default
          });
        }

        if (selectRow) {
          this.BaseComponent = (0, _wrapper4.default)(this.BaseComponent);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var baseProps = _extends({}, this.props, {
          store: this.store
        });

        return _react2.default.createElement(this.BaseComponent, baseProps);
      }
    }]);

    return BootstrapTableContainer;
  }((0, _remoteResolver3.default)(_react.Component));
};

exports.default = withDataStore;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-underscore-dangle: 0 */


var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _sort = __webpack_require__(30);

var _rows = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Store = function () {
  function Store(keyField) {
    _classCallCheck(this, Store);

    this._data = [];
    this._filteredData = [];
    this._keyField = keyField;
    this._sortOrder = undefined;
    this._sortField = undefined;
    this._selected = [];
    this._filters = {};
    this._page = undefined;
    this._sizePerPage = undefined;
  }

  _createClass(Store, [{
    key: 'edit',
    value: function edit(rowId, dataField, newValue) {
      var row = (0, _rows.getRowByRowId)(this)(rowId);
      if (row) _utils2.default.set(row, dataField, newValue);
    }
  }, {
    key: 'setSort',
    value: function setSort(_ref, order, defaultOrder) {
      var dataField = _ref.dataField;

      this.sortOrder = (0, _sort.nextOrder)(this)(dataField, order, defaultOrder);
      this.sortField = dataField;
    }
  }, {
    key: 'sortBy',
    value: function sortBy(_ref2) {
      var sortFunc = _ref2.sortFunc;

      this.data = (0, _sort.sort)(this)(sortFunc);
    }
  }, {
    key: 'getAllData',
    value: function getAllData() {
      return this._data;
    }
  }, {
    key: 'setAllData',
    value: function setAllData(data) {
      this._data = data;
    }
  }, {
    key: 'data',
    get: function get() {
      if (Object.keys(this._filters).length > 0) {
        return this._filteredData;
      }
      return this._data;
    },
    set: function set(data) {
      if (Object.keys(this._filters).length > 0) {
        this._filteredData = data;
      } else {
        this._data = data ? JSON.parse(JSON.stringify(data)) : [];
      }
    }
  }, {
    key: 'filteredData',
    get: function get() {
      return this._filteredData;
    },
    set: function set(filteredData) {
      this._filteredData = filteredData;
    }
  }, {
    key: 'keyField',
    get: function get() {
      return this._keyField;
    },
    set: function set(keyField) {
      this._keyField = keyField;
    }
  }, {
    key: 'sortOrder',
    get: function get() {
      return this._sortOrder;
    },
    set: function set(sortOrder) {
      this._sortOrder = sortOrder;
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    },
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: 'sizePerPage',
    get: function get() {
      return this._sizePerPage;
    },
    set: function set(sizePerPage) {
      this._sizePerPage = sizePerPage;
    }
  }, {
    key: 'sortField',
    get: function get() {
      return this._sortField;
    },
    set: function set(sortField) {
      this._sortField = sortField;
    }
  }, {
    key: 'selected',
    get: function get() {
      return this._selected;
    },
    set: function set(selected) {
      this._selected = selected;
    }
  }, {
    key: 'filters',
    get: function get() {
      return this._filters;
    },
    set: function set(filters) {
      this._filters = filters;
    }
  }]);

  return Store;
}();

exports.default = Store;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextOrder = exports.sort = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint no-nested-ternary: 0 */
/* eslint no-lonely-if: 0 */
/* eslint no-underscore-dangle: 0 */


function comparator(a, b) {
  var result = void 0;
  if (typeof b === 'string') {
    result = b.localeCompare(a);
  } else {
    result = a > b ? -1 : a < b ? 1 : 0;
  }
  return result;
}

var sort = exports.sort = function sort(_ref) {
  var data = _ref.data,
      sortOrder = _ref.sortOrder,
      sortField = _ref.sortField;
  return function (sortFunc) {
    var _data = [].concat(_toConsumableArray(data));
    _data.sort(function (a, b) {
      var result = void 0;
      var valueA = _utils2.default.get(a, sortField);
      var valueB = _utils2.default.get(b, sortField);
      valueA = _utils2.default.isDefined(valueA) ? valueA : '';
      valueB = _utils2.default.isDefined(valueB) ? valueB : '';

      if (sortFunc) {
        result = sortFunc(valueA, valueB, sortOrder, sortField);
      } else {
        if (sortOrder === _const2.default.SORT_DESC) {
          result = comparator(valueA, valueB);
        } else {
          result = comparator(valueB, valueA);
        }
      }
      return result;
    });
    return _data;
  };
};

var nextOrder = exports.nextOrder = function nextOrder(store) {
  return function (field, order) {
    var defaultOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const2.default.SORT_DESC;

    if (order) return order;

    if (field !== store.sortField) {
      return defaultOrder;
    }
    return store.sortOrder === _const2.default.SORT_DESC ? _const2.default.SORT_ASC : _const2.default.SORT_DESC;
  };
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _remoteResolver2 = __webpack_require__(7);

var _remoteResolver3 = _interopRequireDefault(_remoteResolver2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


exports.default = function (Base) {
  var _class, _temp;

  return _temp = _class = function (_remoteResolver) {
    _inherits(SortWrapper, _remoteResolver);

    function SortWrapper(props) {
      _classCallCheck(this, SortWrapper);

      var _this = _possibleConstructorReturn(this, (SortWrapper.__proto__ || Object.getPrototypeOf(SortWrapper)).call(this, props));

      _this.handleSort = _this.handleSort.bind(_this);
      return _this;
    }

    _createClass(SortWrapper, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var _props = this.props,
            columns = _props.columns,
            defaultSorted = _props.defaultSorted,
            defaultSortDirection = _props.defaultSortDirection,
            store = _props.store;
        // defaultSorted is an array, it's ready to use as multi / single sort
        // when we start to support multi sort, please update following code to use array.forEach

        if (defaultSorted && defaultSorted.length > 0) {
          var dataField = defaultSorted[0].dataField;
          var order = defaultSorted[0].order;
          var column = columns.filter(function (col) {
            return col.dataField === dataField;
          });
          if (column.length > 0) {
            store.setSort(column[0], order, defaultSortDirection);

            if (column[0].onSort) {
              column[0].onSort(store.sortField, store.sortOrder);
            }

            if (this.isRemoteSort() || this.isRemotePagination()) {
              this.handleSortChange();
            } else {
              store.sortBy(column[0]);
            }
          }
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (!this.isRemoteSort() && !this.isRemotePagination()) {
          var sortedColumn = void 0;
          for (var i = 0; i < nextProps.columns.length; i += 1) {
            if (nextProps.columns[i].dataField === nextProps.store.sortField) {
              sortedColumn = nextProps.columns[i];
              break;
            }
          }
          if (sortedColumn && sortedColumn.sort) {
            nextProps.store.sortBy(sortedColumn);
          }
        }
      }
    }, {
      key: 'handleSort',
      value: function handleSort(column) {
        var store = this.props.store;

        store.setSort(column, undefined, this.props.defaultSortDirection);

        if (column.onSort) {
          column.onSort(store.sortField, store.sortOrder);
        }

        if (this.isRemoteSort() || this.isRemotePagination()) {
          this.handleSortChange();
        } else {
          store.sortBy(column);
          this.forceUpdate();
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(Base, _extends({}, this.props, {
          onSort: this.handleSort,
          data: this.props.store.data
        }));
      }
    }]);

    return SortWrapper;
  }((0, _remoteResolver3.default)(_react.Component)), _class.propTypes = {
    store: _propTypes2.default.object.isRequired
  }, _temp;
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _selection = __webpack_require__(6);

var _rows = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-param-reassign: 0 */


exports.default = function (Base) {
  var _class, _temp;

  return _temp = _class = function (_Component) {
    _inherits(RowSelectionWrapper, _Component);

    function RowSelectionWrapper(props) {
      _classCallCheck(this, RowSelectionWrapper);

      var _this = _possibleConstructorReturn(this, (RowSelectionWrapper.__proto__ || Object.getPrototypeOf(RowSelectionWrapper)).call(this, props));

      _this.handleRowSelect = _this.handleRowSelect.bind(_this);
      _this.handleAllRowsSelect = _this.handleAllRowsSelect.bind(_this);

      props.store.selected = props.selectRow.selected || [];
      _this.state = {
        selectedRowKeys: props.store.selected
      };
      return _this;
    }

    _createClass(RowSelectionWrapper, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        nextProps.store.selected = nextProps.selectRow.selected || [];
        this.setState(function () {
          return {
            selectedRowKeys: nextProps.store.selected
          };
        });
      }

      /**
       * row selection handler
       * @param {String} rowKey - row key of what was selected.
       * @param {Boolean} checked - next checked status of input button.
       */

    }, {
      key: 'handleRowSelect',
      value: function handleRowSelect(rowKey, checked, rowIndex, e) {
        var _props = this.props,
            _props$selectRow = _props.selectRow,
            mode = _props$selectRow.mode,
            onSelect = _props$selectRow.onSelect,
            store = _props.store;
        var ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;


        var currSelected = [].concat(_toConsumableArray(store.selected));

        if (mode === ROW_SELECT_SINGLE) {
          // when select mode is radio
          currSelected = [rowKey];
        } else if (checked) {
          // when select mode is checkbox
          currSelected.push(rowKey);
        } else {
          currSelected = currSelected.filter(function (value) {
            return value !== rowKey;
          });
        }

        store.selected = currSelected;

        if (onSelect) {
          var row = (0, _rows.getRowByRowId)(store)(rowKey);
          onSelect(row, checked, rowIndex, e);
        }

        this.setState(function () {
          return {
            selectedRowKeys: currSelected
          };
        });
      }

      /**
       * handle all rows selection on header cell by store.selected
       */

    }, {
      key: 'handleAllRowsSelect',
      value: function handleAllRowsSelect(e) {
        var _props2 = this.props,
            store = _props2.store,
            _props2$selectRow = _props2.selectRow,
            onSelectAll = _props2$selectRow.onSelectAll,
            nonSelectable = _props2$selectRow.nonSelectable;

        var selected = (0, _selection.isAnySelectedRow)(store)(nonSelectable);

        var result = !selected;

        var currSelected = result ? (0, _selection.selectableKeys)(store)(nonSelectable) : (0, _selection.unSelectableKeys)(store)(nonSelectable);

        store.selected = currSelected;

        if (onSelectAll) {
          onSelectAll(result, (0, _selection.getSelectedRows)(store), e);
        }

        this.setState(function () {
          return {
            selectedRowKeys: currSelected
          };
        });
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(Base, _extends({}, this.props, {
          onRowSelect: this.handleRowSelect,
          onAllRowsSelect: this.handleAllRowsSelect
        }));
      }
    }]);

    return RowSelectionWrapper;
  }(_react.Component), _class.propTypes = {
    store: _propTypes2.default.object.isRequired,
    selectRow: _propTypes2.default.object.isRequired
  }, _temp;
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA0NjE1YzgyZTcyNWUxZWQxZDRlYiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL3Jvd3MuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvc2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Byb3BzLXJlc29sdmVyL3JlbW90ZS1yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2Jvb3RzdHJhcC10YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvaGVhZGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2hlYWRlci1jZWxsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3NvcnQvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3NvcnQvY2FyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY2FwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9ib2R5LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jZWxsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV2ZW50LWRlbGVnYXRlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9jb2x1bW4tcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL3NvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc29ydC93cmFwcGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vd3JhcHBlci5qcyJdLCJuYW1lcyI6WyJTT1JUX0FTQyIsIlNPUlRfREVTQyIsIlJPV19TRUxFQ1RfU0lOR0xFIiwiUk9XX1NFTEVDVF9NVUxUSVBMRSIsIlJPV19TRUxFQ1RfRElTQUJMRUQiLCJDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRCIsIkNIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFIiwiQ0hFQ0tCT1hfU1RBVFVTX1VOQ0hFQ0tFRCIsInNwbGl0TmVzdGVkIiwic3RyIiwiam9pbiIsInJlcGxhY2UiLCJzcGxpdCIsImdldCIsInRhcmdldCIsImZpZWxkIiwicGF0aEFycmF5IiwicmVzdWx0IiwicmVkdWNlIiwiY3VyciIsInBhdGgiLCJlIiwic2V0IiwidmFsdWUiLCJzYWZlIiwibGV2ZWwiLCJhIiwiYiIsIkVycm9yIiwibGVuZ3RoIiwiaXNGdW5jdGlvbiIsIm9iaiIsImlzT2JqZWN0IiwidHlwZSIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiaXNFbXB0eU9iamVjdCIsImhhc093blByb3BlcnR5IiwicHJvdG90eXBlIiwia2V5cyIsImkiLCJjYWxsIiwiaXNEZWZpbmVkIiwic2xlZXAiLCJmbiIsIm1zIiwic2V0VGltZW91dCIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJpbW1lZGlhdGUiLCJ0aW1lb3V0IiwibGF0ZXIiLCJhcHBseSIsImNhbGxOb3ciLCJjbGVhclRpbWVvdXQiLCJhcHB5IiwibWF0Y2hSb3ciLCJrZXlGaWVsZCIsImlkIiwicm93IiwiZ2V0Um93QnlSb3dJZCIsImRhdGEiLCJmaW5kIiwiaXNTZWxlY3RlZEFsbCIsInNlbGVjdGVkIiwiaXNBbnlTZWxlY3RlZFJvdyIsInNraXBzIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJ4Iiwic2VsZWN0YWJsZUtleXMiLCJtYXAiLCJ1blNlbGVjdGFibGVLZXlzIiwiZ2V0U2VsZWN0ZWRSb3dzIiwic3RvcmUiLCJnZXRSb3ciLCJrIiwic3RhdGUiLCJwcm9wcyIsInBhZ2UiLCJzaXplUGVyUGFnZSIsImZpbHRlcnMiLCJzb3J0RmllbGQiLCJzb3J0T3JkZXIiLCJnZXRBbGxEYXRhIiwicmVtb3RlIiwicGFnaW5hdGlvbiIsInNvcnQiLCJjZWxsRWRpdCIsIm9uVGFibGVDaGFuZ2UiLCJnZXROZXdlc3RTdGF0ZSIsIm5ld1N0YXRlIiwiaXNSZW1vdGVQYWdpbmF0aW9uIiwib3B0aW9ucyIsInBhZ2VTdGFydEluZGV4Iiwicm93SWQiLCJkYXRhRmllbGQiLCJuZXdWYWx1ZSIsIkV4dGVuZEJhc2UiLCJCb290c3RyYXBUYWJsZSIsInZhbGlkYXRlUHJvcHMiLCJuZXh0UHJvcHMiLCJzZXRTdGF0ZSIsImxvYWRpbmciLCJvdmVybGF5IiwiTG9hZGluZ092ZXJsYXkiLCJyZW5kZXJUYWJsZSIsImNvbHVtbnMiLCJjbGFzc2VzIiwic3RyaXBlZCIsImhvdmVyIiwiYm9yZGVyZWQiLCJjb25kZW5zZWQiLCJub0RhdGFJbmRpY2F0aW9uIiwiY2FwdGlvbiIsInJvd1N0eWxlIiwicm93Q2xhc3NlcyIsIndyYXBwZXJDbGFzc2VzIiwicm93RXZlbnRzIiwidGFibGVXcmFwcGVyQ2xhc3MiLCJ0YWJsZUNsYXNzIiwiY2VsbFNlbGVjdGlvbkluZm8iLCJyZXNvbHZlU2VsZWN0Um93UHJvcHMiLCJvblJvd1NlbGVjdCIsImhlYWRlckNlbGxTZWxlY3Rpb25JbmZvIiwicmVzb2x2ZVNlbGVjdFJvd1Byb3BzRm9ySGVhZGVyIiwib25BbGxSb3dzU2VsZWN0IiwiYWxsUm93c1NlbGVjdGVkIiwidGFibGVDYXB0aW9uIiwib25Tb3J0Iiwib25GaWx0ZXIiLCJvbkV4dGVybmFsRmlsdGVyIiwiaXNFbXB0eSIsInZpc2libGVDb2x1bW5TaXplIiwicHJvcFR5cGVzIiwic3RyaW5nIiwiaXNSZXF1aXJlZCIsImFycmF5Iiwib25lT2ZUeXBlIiwiYm9vbCIsInNoYXBlIiwib2JqZWN0Iiwibm9kZSIsInNlbGVjdFJvdyIsIm1vZGUiLCJvbmVPZiIsImNsaWNrVG9TZWxlY3QiLCJjbGlja1RvRWRpdCIsIm9uU2VsZWN0Iiwib25TZWxlY3RBbGwiLCJzdHlsZSIsIm5vblNlbGVjdGFibGUiLCJiZ0NvbG9yIiwiaGlkZVNlbGVjdENvbHVtbiIsInNlbGVjdGlvblJlbmRlcmVyIiwic2VsZWN0aW9uSGVhZGVyUmVuZGVyZXIiLCJkZWZhdWx0U29ydGVkIiwiYXJyYXlPZiIsIm9yZGVyIiwiZGVmYXVsdFNvcnREaXJlY3Rpb24iLCJkZWZhdWx0UHJvcHMiLCJIZWFkZXIiLCJjb2x1bW4iLCJoaWRkZW4iLCJjdXJyU29ydCIsImlzTGFzdFNvcnRpbmciLCJIZWFkZXJDZWxsIiwiaW5kZXgiLCJzb3J0aW5nIiwidGV4dCIsImZpbHRlclJlbmRlcmVyIiwiaGVhZGVyVGl0bGUiLCJoZWFkZXJBbGlnbiIsImhlYWRlckZvcm1hdHRlciIsImhlYWRlckV2ZW50cyIsImhlYWRlckNsYXNzZXMiLCJoZWFkZXJTdHlsZSIsImhlYWRlckF0dHJzIiwiaGVhZGVyU29ydGluZ0NsYXNzZXMiLCJoZWFkZXJTb3J0aW5nU3R5bGUiLCJjZWxsQXR0cnMiLCJzb3J0U3ltYm9sIiwiZmlsdGVyRWxtIiwiY2VsbFN0eWxlIiwiY2VsbENsYXNzZXMiLCJ0aXRsZSIsInRleHRBbGlnbiIsImN1c3RvbUNsaWNrIiwib25DbGljayIsImNsYXNzTmFtZSIsIm9uQ3VzdG9tRmlsdGVyIiwiY2hpbGRyZW4iLCJzb3J0RWxlbWVudCIsImZpbHRlckVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZm9ybWF0dGVyIiwiZm9ybWF0RXh0cmFEYXRhIiwiYW55IiwiZXZlbnRzIiwiYWxpZ24iLCJhdHRycyIsInNvcnRGdW5jIiwiZWRpdG9yIiwiZWRpdGFibGUiLCJlZGl0Q2VsbFN0eWxlIiwiZWRpdENlbGxDbGFzc2VzIiwiZWRpdG9yU3R5bGUiLCJlZGl0b3JDbGFzc2VzIiwiZWRpdG9yUmVuZGVyZXIiLCJ2YWxpZGF0b3IiLCJmaWx0ZXJWYWx1ZSIsIm51bWJlciIsIlNvcnRTeW1ib2wiLCJTb3J0Q2FyZXQiLCJvcmRlckNsYXNzIiwiZHJvcHVwIiwiQ2hlY2tCb3giLCJjaGVja2VkIiwiaW5kZXRlcm1pbmF0ZSIsImlucHV0IiwiU2VsZWN0aW9uSGVhZGVyQ2VsbCIsImhhbmRsZUNoZWNrQm94Q2xpY2siLCJiaW5kIiwiY2hlY2tlZFN0YXR1cyIsImNvbnRlbnQiLCJDYXB0aW9uIiwiQm9keSIsInNlbGVjdGVkUm93S2V5cyIsImluZGljYXRpb24iLCJub25FZGl0YWJsZVJvd3MiLCJrZXkiLCJpbmRleE9mIiwic2VsZWN0ZWRTdHlsZSIsInNlbGVjdGVkQ2xhc3NlcyIsImJhY2tncm91bmRDb2xvciIsInNlbGVjdGFibGUiLCJSb3ciLCJyb3dJbmRleCIsImVkaXRhYmxlUm93Iiwib25TdGFydCIsIkVkaXRpbmdDZWxsIiwiZWRpdGluZ1Jvd0lkeCIsInJpZHgiLCJlZGl0aW5nQ29sSWR4IiwiY2lkeCIsIkNMSUNLX1RPX0NFTExfRURJVCIsIkRCQ0xJQ0tfVE9fQ0VMTF9FRElUIiwicmVzdCIsInRyQXR0cnMiLCJkZWxlZ2F0ZSIsImVkaXRDZWxsc3R5bGUiLCJlZGl0Q2VsbGNsYXNzZXMiLCJDZWxsIiwiaGFuZGxlRWRpdGluZ0NlbGwiLCJjb2x1bW5JbmRleCIsImRiY2xpY2tUb0VkaXQiLCJjdXN0b21EYkNsaWNrIiwib25Eb3VibGVDbGljayIsImNlbGxUaXRsZSIsIlNlbGVjdGlvbkNlbGwiLCJoYW5kbGVDbGljayIsImlucHV0VHlwZSIsInJvd0tleSIsImRpc2FibGVkIiwiY2xpY2tOdW0iLCJjcmVhdGVEZWZhdWx0RXZlbnRIYW5kbGVyIiwiY3JlYXRlQ2xpY2tFdmVudEhhbmRsZXIiLCJjYiIsIkRFTEFZX0ZPUl9EQkNMSUNLIiwiY2xpY2tGbiIsIm5ld0F0dHJzIiwiZm9yRWFjaCIsImF0dHIiLCJSb3dTZWN0aW9uIiwiY29sU3BhbiIsImluY2x1ZGVTZWxlY3RDb2x1bW4iLCJjb2x1bW5MZW4iLCJjIiwid2l0aERhdGFTdG9yZSIsIndyYXBDb21wb25lbnRzIiwic2V0QWxsRGF0YSIsIkJhc2VDb21wb25lbnQiLCJCYXNlIiwid3JhcHBlckZhY3RvcnkiLCJyZW1vdGVSZXNvbHZlciIsImNvbCIsIl8iLCJiYXNlUHJvcHMiLCJTdG9yZSIsIl9kYXRhIiwiX2ZpbHRlcmVkRGF0YSIsIl9rZXlGaWVsZCIsIl9zb3J0T3JkZXIiLCJ1bmRlZmluZWQiLCJfc29ydEZpZWxkIiwiX3NlbGVjdGVkIiwiX2ZpbHRlcnMiLCJfcGFnZSIsIl9zaXplUGVyUGFnZSIsImRlZmF1bHRPcmRlciIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImZpbHRlcmVkRGF0YSIsImNvbXBhcmF0b3IiLCJsb2NhbGVDb21wYXJlIiwidmFsdWVBIiwidmFsdWVCIiwibmV4dE9yZGVyIiwiaGFuZGxlU29ydCIsInNldFNvcnQiLCJpc1JlbW90ZVNvcnQiLCJoYW5kbGVTb3J0Q2hhbmdlIiwic29ydEJ5Iiwic29ydGVkQ29sdW1uIiwiZm9yY2VVcGRhdGUiLCJoYW5kbGVSb3dTZWxlY3QiLCJoYW5kbGVBbGxSb3dzU2VsZWN0IiwiY3VyclNlbGVjdGVkIiwicHVzaCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQSwrQzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7a0JDN0JlO0FBQ2JBLFlBQVUsS0FERztBQUViQyxhQUFXLE1BRkU7QUFHYkMscUJBQW1CLE9BSE47QUFJYkMsdUJBQXFCLFVBSlI7QUFLYkMsdUJBQXFCLHFCQUxSO0FBTWJDLDJCQUF5QixTQU5aO0FBT2JDLGlDQUErQixlQVBsQjtBQVFiQyw2QkFBMkI7QUFSZCxDOzs7Ozs7Ozs7Ozs7Ozs7QUNBZjtBQUNBO0FBQ0E7O0FBRUEsU0FBU0MsV0FBVCxDQUFxQkMsR0FBckIsRUFBMEI7QUFDeEIsU0FBTyxDQUFDQSxHQUFELEVBQ0pDLElBREksQ0FDQyxH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O0FBQUEsaUJBQU87QUFDbkI2SCw2QkFBaUIyRjtBQURFLFdBQVA7QUFBQSxTQUFkO0FBR0Q7QUFsRlU7QUFBQTtBQUFBLCtCQW9GRjtBQUNQLGVBQ0UsOEJBQUMsSUFBRCxlQUNPLEtBQUtoUCxLQURaO0FBRUUsdUJBQWMsS0FBSzhPLGVBRnJCO0FBR0UsMkJBQWtCLEtBQUtDO0FBSHpCLFdBREY7QUFPRDtBQTVGVTs7QUFBQTtBQUFBLDhCQUVKdkwsU0FGSSxHQUVRO0FBQ2pCNUQsV0FBTyxvQkFBVW1FLE1BQVYsQ0FBaUJMLFVBRFA7QUFFakJPLGVBQVcsb0JBQVVGLE1BQVYsQ0FBaUJMO0FBRlgsR0FGUjtBQUFBLEMiLCJmaWxlIjoicmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9kaXN0L3JlYWN0LWJvb3RzdHJhcC10YWJsZS1uZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUmVhY3RCb290c3RyYXBUYWJsZTJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmVhY3RCb290c3RyYXBUYWJsZTJcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA4KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA0NjE1YzgyZTcyNWUxZWQxZDRlYiIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZXhwb3J0IGRlZmF1bHQge1xuICBTT1JUX0FTQzogJ2FzYycsXG4gIFNPUlRfREVTQzogJ2Rlc2MnLFxuICBST1dfU0VMRUNUX1NJTkdMRTogJ3JhZGlvJyxcbiAgUk9XX1NFTEVDVF9NVUxUSVBMRTogJ2NoZWNrYm94JyxcbiAgUk9XX1NFTEVDVF9ESVNBQkxFRDogJ1JPV19TRUxFQ1RfRElTQUJMRUQnLFxuICBDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRDogJ2NoZWNrZWQnLFxuICBDSEVDS0JPWF9TVEFUVVNfSU5ERVRFUk1JTkFURTogJ2luZGV0ZXJtaW5hdGUnLFxuICBDSEVDS0JPWF9TVEFUVVNfVU5DSEVDS0VEOiAndW5jaGVja2VkJ1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnN0LmpzIiwiLyogZXNsaW50IG5vLWVtcHR5OiAwICovXG4vKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IDAgKi9cbi8qIGVzbGludCBwcmVmZXItcmVzdC1wYXJhbXM6IDAgKi9cblxuZnVuY3Rpb24gc3BsaXROZXN0ZWQoc3RyKSB7XG4gIHJldHVybiBbc3RyXVxuICAgIC5qb2luKCcuJylcbiAgICAucmVwbGFjZSgvXFxbL2csICcuJylcbiAgICAucmVwbGFjZSgvXFxdL2csICcnKVxuICAgIC5zcGxpdCgnLicpO1xufVxuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBmaWVsZCkge1xuICBjb25zdCBwYXRoQXJyYXkgPSBzcGxpdE5lc3RlZChmaWVsZCk7XG4gIGxldCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gcGF0aEFycmF5LnJlZHVjZSgoY3VyciwgcGF0aCkgPT4gY3VycltwYXRoXSwgdGFyZ2V0KTtcbiAgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgZmllbGQsIHZhbHVlLCBzYWZlID0gZmFsc2UpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gc3BsaXROZXN0ZWQoZmllbGQpO1xuICBsZXQgbGV2ZWwgPSAwO1xuICBwYXRoQXJyYXkucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgbGV2ZWwgKz0gMTtcbiAgICBpZiAodHlwZW9mIGFbYl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoIXNhZmUpIHRocm93IG5ldyBFcnJvcihgJHthfS4ke2J9IGlzIHVuZGVmaW5lZGApO1xuICAgICAgYVtiXSA9IHt9O1xuICAgICAgcmV0dXJuIGFbYl07XG4gICAgfVxuXG4gICAgaWYgKGxldmVsID09PSBwYXRoQXJyYXkubGVuZ3RoKSB7XG4gICAgICBhW2JdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhW2JdO1xuICB9LCB0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICYmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgT2JqZWN0LiB0aGUgYE9iamVjdGAgZXhjZXB0IGBGdW5jdGlvbmAgYW5kIGBBcnJheS5gXG4gKlxuICogQHBhcmFtIHsqfSBvYmogLSBUaGUgdmFsdWUgZ29ubmEgY2hlY2tcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2Ygb2JqO1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGUgPT09ICdvYmplY3QnICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKGZuLCBtcykge1xuICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiBmbigpLCBtcyk7XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICBsZXQgdGltZW91dDtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuICAgICAgdGltZW91dCA9IG51bGw7XG5cbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcblxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCB8fCAwKTtcblxuICAgIGlmIChjYWxsTm93KSB7XG4gICAgICBmdW5jLmFwcHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0LFxuICBzZXQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzT2JqZWN0LFxuICBpc0VtcHR5T2JqZWN0LFxuICBpc0RlZmluZWQsXG4gIHNsZWVwLFxuICBkZWJvdW5jZVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3V0aWxzLmpzIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNiBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpKTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcbmV4cG9ydCBjb25zdCBtYXRjaFJvdyA9IChrZXlGaWVsZCwgaWQpID0+IHJvdyA9PiByb3dba2V5RmllbGRdID09PSBpZDtcblxuZXhwb3J0IGNvbnN0IGdldFJvd0J5Um93SWQgPSAoeyBkYXRhLCBrZXlGaWVsZCB9KSA9PiBpZCA9PiBkYXRhLmZpbmQobWF0Y2hSb3coa2V5RmllbGQsIGlkKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9yb3dzLmpzIiwiaW1wb3J0IF8gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Um93QnlSb3dJZCB9IGZyb20gJy4vcm93cyc7XG5cbmV4cG9ydCBjb25zdCBpc1NlbGVjdGVkQWxsID0gKHsgZGF0YSwgc2VsZWN0ZWQgfSkgPT4gZGF0YS5sZW5ndGggPT09IHNlbGVjdGVkLmxlbmd0aDtcblxuZXhwb3J0IGNvbnN0IGlzQW55U2VsZWN0ZWRSb3cgPSAoeyBzZWxlY3RlZCB9KSA9PiAoc2tpcHMgPSBbXSkgPT4ge1xuICBpZiAoc2tpcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHNlbGVjdGVkLmxlbmd0aCA+IDA7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGVkLmZpbHRlcih4ID0+ICFza2lwcy5pbmNsdWRlcyh4KSkubGVuZ3RoO1xufTtcblxuZXhwb3J0IGNvbnN0IHNlbGVjdGFibGVLZXlzID0gKHsgZGF0YSwga2V5RmllbGQgfSkgPT4gKHNraXBzID0gW10pID0+IHtcbiAgaWYgKHNraXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkYXRhLm1hcChyb3cgPT4gXy5nZXQocm93LCBrZXlGaWVsZCkpO1xuICB9XG4gIHJldHVybiBkYXRhXG4gICAgLmZpbHRlcihyb3cgPT4gIXNraXBzLmluY2x1ZGVzKF8uZ2V0KHJvdywga2V5RmllbGQpKSlcbiAgICAubWFwKHJvdyA9PiBfLmdldChyb3csIGtleUZpZWxkKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdW5TZWxlY3RhYmxlS2V5cyA9ICh7IHNlbGVjdGVkIH0pID0+IChza2lwcyA9IFtdKSA9PiB7XG4gIGlmIChza2lwcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGVkLmZpbHRlcih4ID0+IHNraXBzLmluY2x1ZGVzKHgpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTZWxlY3RlZFJvd3MgPSAoc3RvcmUpID0+IHtcbiAgY29uc3QgZ2V0Um93ID0gZ2V0Um93QnlSb3dJZChzdG9yZSk7XG4gIHJldHVybiBzdG9yZS5zZWxlY3RlZC5tYXAoayA9PiBnZXRSb3coaykpO1xufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvc2VsZWN0aW9uLmpzIiwiaW1wb3J0IF8gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbmRCYXNlID0+XG4gIGNsYXNzIFJlbW90ZVJlc29sdmVyIGV4dGVuZHMgRXh0ZW5kQmFzZSB7XG4gICAgZ2V0TmV3ZXN0U3RhdGUoc3RhdGUgPSB7fSkge1xuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLnN0b3JlIHx8IHRoaXMucHJvcHMuc3RvcmU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlOiBzdG9yZS5wYWdlLFxuICAgICAgICBzaXplUGVyUGFnZTogc3RvcmUuc2l6ZVBlclBhZ2UsXG4gICAgICAgIGZpbHRlcnM6IHN0b3JlLmZpbHRlcnMsXG4gICAgICAgIHNvcnRGaWVsZDogc3RvcmUuc29ydEZpZWxkLFxuICAgICAgICBzb3J0T3JkZXI6IHN0b3JlLnNvcnRPcmRlcixcbiAgICAgICAgZGF0YTogc3RvcmUuZ2V0QWxsRGF0YSgpLFxuICAgICAgICAuLi5zdGF0ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpc1JlbW90ZVBhZ2luYXRpb24oKSB7XG4gICAgICBjb25zdCB7IHJlbW90ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiByZW1vdGUgPT09IHRydWUgfHwgKF8uaXNPYmplY3QocmVtb3RlKSAmJiByZW1vdGUucGFnaW5hdGlvbik7XG4gICAgfVxuXG4gICAgaXNSZW1vdGVGaWx0ZXJpbmcoKSB7XG4gICAgICBjb25zdCB7IHJlbW90ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiByZW1vdGUgPT09IHRydWUgfHwgKF8uaXNPYmplY3QocmVtb3RlKSAmJiByZW1vdGUuZmlsdGVyKTtcbiAgICB9XG5cbiAgICBpc1JlbW90ZVNvcnQoKSB7XG4gICAgICBjb25zdCB7IHJlbW90ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiByZW1vdGUgPT09IHRydWUgfHwgKF8uaXNPYmplY3QocmVtb3RlKSAmJiByZW1vdGUuc29ydCk7XG4gICAgfVxuXG4gICAgaXNSZW1vdGVDZWxsRWRpdCgpIHtcbiAgICAgIGNvbnN0IHsgcmVtb3RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgcmV0dXJuIHJlbW90ZSA9PT0gdHJ1ZSB8fCAoXy5pc09iamVjdChyZW1vdGUpICYmIHJlbW90ZS5jZWxsRWRpdCk7XG4gICAgfVxuXG4gICAgaGFuZGxlUmVtb3RlUGFnZUNoYW5nZSgpIHtcbiAgICAgIHRoaXMucHJvcHMub25UYWJsZUNoYW5nZSgncGFnaW5hdGlvbicsIHRoaXMuZ2V0TmV3ZXN0U3RhdGUoKSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUmVtb3RlRmlsdGVyQ2hhbmdlKCkge1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7fTtcbiAgICAgIGlmICh0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnByb3BzLnBhZ2luYXRpb24ub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbmV3U3RhdGUucGFnZSA9IF8uaXNEZWZpbmVkKG9wdGlvbnMucGFnZVN0YXJ0SW5kZXgpID8gb3B0aW9ucy5wYWdlU3RhcnRJbmRleCA6IDE7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLm9uVGFibGVDaGFuZ2UoJ2ZpbHRlcicsIHRoaXMuZ2V0TmV3ZXN0U3RhdGUobmV3U3RhdGUpKTtcbiAgICB9XG5cbiAgICBoYW5kbGVTb3J0Q2hhbmdlKCkge1xuICAgICAgdGhpcy5wcm9wcy5vblRhYmxlQ2hhbmdlKCdzb3J0JywgdGhpcy5nZXROZXdlc3RTdGF0ZSgpKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDZWxsQ2hhbmdlKHJvd0lkLCBkYXRhRmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgICBjb25zdCBjZWxsRWRpdCA9IHsgcm93SWQsIGRhdGFGaWVsZCwgbmV3VmFsdWUgfTtcbiAgICAgIHRoaXMucHJvcHMub25UYWJsZUNoYW5nZSgnY2VsbEVkaXQnLCB0aGlzLmdldE5ld2VzdFN0YXRlKHsgY2VsbEVkaXQgfSkpO1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Byb3BzLXJlc29sdmVyL3JlbW90ZS1yZXNvbHZlci5qcyIsImltcG9ydCBCb290c3RyYXBUYWJsZSBmcm9tICcuL3NyYy9ib290c3RyYXAtdGFibGUnO1xuaW1wb3J0IHdpdGhEYXRhU3RvcmUgZnJvbSAnLi9zcmMvY29udGFpbmVyJztcblxuZXhwb3J0IGRlZmF1bHQgd2l0aERhdGFTdG9yZShCb290c3RyYXBUYWJsZSk7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvaW5kZXguanMiLCIvKiBlc2xpbnQgYXJyb3ctYm9keS1zdHlsZTogMCAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IEhlYWRlciBmcm9tICcuL2hlYWRlcic7XG5pbXBvcnQgQ2FwdGlvbiBmcm9tICcuL2NhcHRpb24nO1xuaW1wb3J0IEJvZHkgZnJvbSAnLi9ib2R5JztcbmltcG9ydCBQcm9wc0Jhc2VSZXNvbHZlciBmcm9tICcuL3Byb3BzLXJlc29sdmVyJztcbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcbmltcG9ydCB7IGlzU2VsZWN0ZWRBbGwgfSBmcm9tICcuL3N0b3JlL3NlbGVjdGlvbic7XG5cbmNsYXNzIEJvb3RzdHJhcFRhYmxlIGV4dGVuZHMgUHJvcHNCYXNlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMudmFsaWRhdGVQcm9wcygpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRhdGE6IHByb3BzLmRhdGFcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRhdGE6IG5leHRQcm9wcy5kYXRhXG4gICAgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBsb2FkaW5nLCBvdmVybGF5IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvdmVybGF5KSB7XG4gICAgICBjb25zdCBMb2FkaW5nT3ZlcmxheSA9IG92ZXJsYXkobG9hZGluZyk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8TG9hZGluZ092ZXJsYXk+XG4gICAgICAgICAgeyB0aGlzLnJlbmRlclRhYmxlKCkgfVxuICAgICAgICA8L0xvYWRpbmdPdmVybGF5PlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFibGUoKTtcbiAgfVxuXG4gIHJlbmRlclRhYmxlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0b3JlLFxuICAgICAgY29sdW1ucyxcbiAgICAgIGtleUZpZWxkLFxuICAgICAgaWQsXG4gICAgICBjbGFzc2VzLFxuICAgICAgc3RyaXBlZCxcbiAgICAgIGhvdmVyLFxuICAgICAgYm9yZGVyZWQsXG4gICAgICBjb25kZW5zZWQsXG4gICAgICBub0RhdGFJbmRpY2F0aW9uLFxuICAgICAgY2FwdGlvbixcbiAgICAgIHJvd1N0eWxlLFxuICAgICAgcm93Q2xhc3NlcyxcbiAgICAgIHdyYXBwZXJDbGFzc2VzLFxuICAgICAgcm93RXZlbnRzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB0YWJsZVdyYXBwZXJDbGFzcyA9IGNzKCdyZWFjdC1ib290c3RyYXAtdGFibGUnLCB3cmFwcGVyQ2xhc3Nlcyk7XG5cbiAgICBjb25zdCB0YWJsZUNsYXNzID0gY3MoJ3RhYmxlJywge1xuICAgICAgJ3RhYmxlLXN0cmlwZWQnOiBzdHJpcGVkLFxuICAgICAgJ3RhYmxlLWhvdmVyJzogaG92ZXIsXG4gICAgICAndGFibGUtYm9yZGVyZWQnOiBib3JkZXJlZCxcbiAgICAgICd0YWJsZS1jb25kZW5zZWQnOiBjb25kZW5zZWRcbiAgICB9LCBjbGFzc2VzKTtcblxuICAgIGNvbnN0IGNlbGxTZWxlY3Rpb25JbmZvID0gdGhpcy5yZXNvbHZlU2VsZWN0Um93UHJvcHMoe1xuICAgICAgb25Sb3dTZWxlY3Q6IHRoaXMucHJvcHMub25Sb3dTZWxlY3RcbiAgICB9KTtcblxuICAgIGNvbnN0IGhlYWRlckNlbGxTZWxlY3Rpb25JbmZvID0gdGhpcy5yZXNvbHZlU2VsZWN0Um93UHJvcHNGb3JIZWFkZXIoe1xuICAgICAgb25BbGxSb3dzU2VsZWN0OiB0aGlzLnByb3BzLm9uQWxsUm93c1NlbGVjdCxcbiAgICAgIHNlbGVjdGVkOiBzdG9yZS5zZWxlY3RlZCxcbiAgICAgIGFsbFJvd3NTZWxlY3RlZDogaXNTZWxlY3RlZEFsbChzdG9yZSlcbiAgICB9KTtcblxuICAgIGNvbnN0IHRhYmxlQ2FwdGlvbiA9IChjYXB0aW9uICYmIDxDYXB0aW9uPnsgY2FwdGlvbiB9PC9DYXB0aW9uPik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9eyB0YWJsZVdyYXBwZXJDbGFzcyB9PlxuICAgICAgICA8dGFibGUgaWQ9eyBpZCB9IGNsYXNzTmFtZT17IHRhYmxlQ2xhc3MgfT5cbiAgICAgICAgICB7IHRhYmxlQ2FwdGlvbiB9XG4gICAgICAgICAgPEhlYWRlclxuICAgICAgICAgICAgY29sdW1ucz17IGNvbHVtbnMgfVxuICAgICAgICAgICAgc29ydEZpZWxkPXsgc3RvcmUuc29ydEZpZWxkIH1cbiAgICAgICAgICAgIHNvcnRPcmRlcj17IHN0b3JlLnNvcnRPcmRlciB9XG4gICAgICAgICAgICBvblNvcnQ9eyB0aGlzLnByb3BzLm9uU29ydCB9XG4gICAgICAgICAgICBvbkZpbHRlcj17IHRoaXMucHJvcHMub25GaWx0ZXIgfVxuICAgICAgICAgICAgb25FeHRlcm5hbEZpbHRlcj17IHRoaXMucHJvcHMub25FeHRlcm5hbEZpbHRlciB9XG4gICAgICAgICAgICBzZWxlY3RSb3c9eyBoZWFkZXJDZWxsU2VsZWN0aW9uSW5mbyB9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8Qm9keVxuICAgICAgICAgICAgZGF0YT17IHRoaXMuc3RhdGUuZGF0YSB9XG4gICAgICAgICAgICBrZXlGaWVsZD17IGtleUZpZWxkIH1cbiAgICAgICAgICAgIGNvbHVtbnM9eyBjb2x1bW5zIH1cbiAgICAgICAgICAgIGlzRW1wdHk9eyB0aGlzLmlzRW1wdHkoKSB9XG4gICAgICAgICAgICB2aXNpYmxlQ29sdW1uU2l6ZT17IHRoaXMudmlzaWJsZUNvbHVtblNpemUoKSB9XG4gICAgICAgICAgICBub0RhdGFJbmRpY2F0aW9uPXsgbm9EYXRhSW5kaWNhdGlvbiB9XG4gICAgICAgICAgICBjZWxsRWRpdD17IHRoaXMucHJvcHMuY2VsbEVkaXQgfHwge30gfVxuICAgICAgICAgICAgc2VsZWN0Um93PXsgY2VsbFNlbGVjdGlvbkluZm8gfVxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dLZXlzPXsgc3RvcmUuc2VsZWN0ZWQgfVxuICAgICAgICAgICAgcm93U3R5bGU9eyByb3dTdHlsZSB9XG4gICAgICAgICAgICByb3dDbGFzc2VzPXsgcm93Q2xhc3NlcyB9XG4gICAgICAgICAgICByb3dFdmVudHM9eyByb3dFdmVudHMgfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvdGFibGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbkJvb3RzdHJhcFRhYmxlLnByb3BUeXBlcyA9IHtcbiAga2V5RmllbGQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICByZW1vdGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHBhZ2luYXRpb246IFByb3BUeXBlcy5ib29sXG4gIH0pXSksXG4gIHN0b3JlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBub0RhdGFJbmRpY2F0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICBzdHJpcGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgYm9yZGVyZWQ6IFByb3BUeXBlcy5ib29sLFxuICBob3ZlcjogUHJvcFR5cGVzLmJvb2wsXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc2VzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB3cmFwcGVyQ2xhc3NlczogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29uZGVuc2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2FwdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLm5vZGUsXG4gICAgUHJvcFR5cGVzLnN0cmluZ1xuICBdKSxcbiAgcGFnaW5hdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgZmlsdGVyOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjZWxsRWRpdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2VsZWN0Um93OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIG1vZGU6IFByb3BUeXBlcy5vbmVPZihbQ29uc3QuUk9XX1NFTEVDVF9TSU5HTEUsIENvbnN0LlJPV19TRUxFQ1RfTVVMVElQTEVdKS5pc1JlcXVpcmVkLFxuICAgIGNsaWNrVG9TZWxlY3Q6IFByb3BUeXBlcy5ib29sLFxuICAgIGNsaWNrVG9FZGl0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvblNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TZWxlY3RBbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgIHN0eWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGNsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgbm9uU2VsZWN0YWJsZTogUHJvcFR5cGVzLmFycmF5LFxuICAgIGJnQ29sb3I6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgaGlkZVNlbGVjdENvbHVtbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgc2VsZWN0aW9uUmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIHNlbGVjdGlvbkhlYWRlclJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuY1xuICB9KSxcbiAgb25Sb3dTZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICBvbkFsbFJvd3NTZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICByb3dTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgcm93RXZlbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICByb3dDbGFzc2VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICBkZWZhdWx0U29ydGVkOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGRhdGFGaWVsZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfREVTQywgQ29uc3QuU09SVF9BU0NdKS5pc1JlcXVpcmVkXG4gIH0pKSxcbiAgZGVmYXVsdFNvcnREaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbQ29uc3QuU09SVF9ERVNDLCBDb25zdC5TT1JUX0FTQ10pLFxuICBvdmVybGF5OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UYWJsZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25FeHRlcm5hbEZpbHRlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbkJvb3RzdHJhcFRhYmxlLmRlZmF1bHRQcm9wcyA9IHtcbiAgcmVtb3RlOiBmYWxzZSxcbiAgc3RyaXBlZDogZmFsc2UsXG4gIGJvcmRlcmVkOiB0cnVlLFxuICBob3ZlcjogZmFsc2UsXG4gIGNvbmRlbnNlZDogZmFsc2UsXG4gIG5vRGF0YUluZGljYXRpb246IG51bGxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJvb3RzdHJhcFRhYmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvYm9vdHN0cmFwLXRhYmxlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4vY29uc3QnO1xuXG5pbXBvcnQgSGVhZGVyQ2VsbCBmcm9tICcuL2hlYWRlci1jZWxsJztcbmltcG9ydCBTZWxlY3Rpb25IZWFkZXJDZWxsIGZyb20gJy4vcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwnO1xuXG5jb25zdCBIZWFkZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBST1dfU0VMRUNUX0RJU0FCTEVEIH0gPSBDb25zdDtcblxuICBjb25zdCB7XG4gICAgY29sdW1ucyxcbiAgICBvblNvcnQsXG4gICAgb25GaWx0ZXIsXG4gICAgc29ydEZpZWxkLFxuICAgIHNvcnRPcmRlcixcbiAgICBzZWxlY3RSb3csXG4gICAgb25FeHRlcm5hbEZpbHRlclxuICB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8dGhlYWQ+XG4gICAgICA8dHI+XG4gICAgICAgIHtcbiAgICAgICAgICAoc2VsZWN0Um93Lm1vZGUgIT09IFJPV19TRUxFQ1RfRElTQUJMRUQgJiYgIXNlbGVjdFJvdy5oaWRlU2VsZWN0Q29sdW1uKVxuICAgICAgICAgICAgPyA8U2VsZWN0aW9uSGVhZGVyQ2VsbCB7IC4uLnNlbGVjdFJvdyB9IC8+IDogbnVsbFxuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICBjb2x1bW5zLm1hcCgoY29sdW1uLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbHVtbi5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyclNvcnQgPSBjb2x1bW4uZGF0YUZpZWxkID09PSBzb3J0RmllbGQ7XG4gICAgICAgICAgICAgIGNvbnN0IGlzTGFzdFNvcnRpbmcgPSBjb2x1bW4uZGF0YUZpZWxkID09PSBzb3J0RmllbGQ7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8SGVhZGVyQ2VsbFxuICAgICAgICAgICAgICAgICAgaW5kZXg9eyBpIH1cbiAgICAgICAgICAgICAgICAgIGtleT17IGNvbHVtbi5kYXRhRmllbGQgfVxuICAgICAgICAgICAgICAgICAgY29sdW1uPXsgY29sdW1uIH1cbiAgICAgICAgICAgICAgICAgIG9uU29ydD17IG9uU29ydCB9XG4gICAgICAgICAgICAgICAgICBzb3J0aW5nPXsgY3VyclNvcnQgfVxuICAgICAgICAgICAgICAgICAgb25GaWx0ZXI9eyBvbkZpbHRlciB9XG4gICAgICAgICAgICAgICAgICBvbkV4dGVybmFsRmlsdGVyPXsgb25FeHRlcm5hbEZpbHRlciB9XG4gICAgICAgICAgICAgICAgICBzb3J0T3JkZXI9eyBzb3J0T3JkZXIgfVxuICAgICAgICAgICAgICAgICAgaXNMYXN0U29ydGluZz17IGlzTGFzdFNvcnRpbmcgfVxuICAgICAgICAgICAgICAgIC8+KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICk7XG59O1xuXG5IZWFkZXIucHJvcFR5cGVzID0ge1xuICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgb25Tb3J0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBzb3J0RmllbGQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHNvcnRPcmRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgc2VsZWN0Um93OiBQcm9wVHlwZXMub2JqZWN0LFxuICBvbkV4dGVybmFsRmlsdGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvaGVhZGVyLmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcbmltcG9ydCBTb3J0U3ltYm9sIGZyb20gJy4vc29ydC9zeW1ib2wnO1xuaW1wb3J0IFNvcnRDYXJldCBmcm9tICcuL3NvcnQvY2FyZXQnO1xuaW1wb3J0IF8gZnJvbSAnLi91dGlscyc7XG5cblxuY29uc3QgSGVhZGVyQ2VsbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgY29sdW1uLFxuICAgIGluZGV4LFxuICAgIG9uU29ydCxcbiAgICBzb3J0aW5nLFxuICAgIHNvcnRPcmRlcixcbiAgICBpc0xhc3RTb3J0aW5nLFxuICAgIG9uRmlsdGVyLFxuICAgIG9uRXh0ZXJuYWxGaWx0ZXJcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHtcbiAgICB0ZXh0LFxuICAgIHNvcnQsXG4gICAgZmlsdGVyLFxuICAgIGZpbHRlclJlbmRlcmVyLFxuICAgIGhlYWRlclRpdGxlLFxuICAgIGhlYWRlckFsaWduLFxuICAgIGhlYWRlckZvcm1hdHRlcixcbiAgICBoZWFkZXJFdmVudHMsXG4gICAgaGVhZGVyQ2xhc3NlcyxcbiAgICBoZWFkZXJTdHlsZSxcbiAgICBoZWFkZXJBdHRycyxcbiAgICBoZWFkZXJTb3J0aW5nQ2xhc3NlcyxcbiAgICBoZWFkZXJTb3J0aW5nU3R5bGVcbiAgfSA9IGNvbHVtbjtcblxuICBjb25zdCBjZWxsQXR0cnMgPSB7XG4gICAgLi4uXy5pc0Z1bmN0aW9uKGhlYWRlckF0dHJzKSA/IGhlYWRlckF0dHJzKGNvbHVtbiwgaW5kZXgpIDogaGVhZGVyQXR0cnMsXG4gICAgLi4uaGVhZGVyRXZlbnRzXG4gIH07XG5cbiAgbGV0IHNvcnRTeW1ib2w7XG4gIGxldCBmaWx0ZXJFbG07XG4gIGxldCBjZWxsU3R5bGUgPSB7fTtcbiAgbGV0IGNlbGxDbGFzc2VzID0gXy5pc0Z1bmN0aW9uKGhlYWRlckNsYXNzZXMpID8gaGVhZGVyQ2xhc3Nlcyhjb2x1bW4sIGluZGV4KSA6IGhlYWRlckNsYXNzZXM7XG5cbiAgaWYgKGhlYWRlclN0eWxlKSB7XG4gICAgY2VsbFN0eWxlID0gXy5pc0Z1bmN0aW9uKGhlYWRlclN0eWxlKSA/IGhlYWRlclN0eWxlKGNvbHVtbiwgaW5kZXgpIDogaGVhZGVyU3R5bGU7XG4gIH1cblxuICBpZiAoaGVhZGVyVGl0bGUpIHtcbiAgICBjZWxsQXR0cnMudGl0bGUgPSBfLmlzRnVuY3Rpb24oaGVhZGVyVGl0bGUpID8gaGVhZGVyVGl0bGUoY29sdW1uLCBpbmRleCkgOiB0ZXh0O1xuICB9XG5cbiAgaWYgKGhlYWRlckFsaWduKSB7XG4gICAgY2VsbFN0eWxlLnRleHRBbGlnbiA9IF8uaXNGdW5jdGlvbihoZWFkZXJBbGlnbikgPyBoZWFkZXJBbGlnbihjb2x1bW4sIGluZGV4KSA6IGhlYWRlckFsaWduO1xuICB9XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBjb25zdCBjdXN0b21DbGljayA9IGNlbGxBdHRycy5vbkNsaWNrO1xuICAgIGNlbGxBdHRycy5vbkNsaWNrID0gKGUpID0+IHtcbiAgICAgIG9uU29ydChjb2x1bW4pO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihjdXN0b21DbGljaykpIGN1c3RvbUNsaWNrKGUpO1xuICAgIH07XG4gICAgY2VsbEF0dHJzLmNsYXNzTmFtZSA9IGNzKGNlbGxBdHRycy5jbGFzc05hbWUsICdzb3J0YWJsZScpO1xuXG4gICAgaWYgKHNvcnRpbmcpIHtcbiAgICAgIHNvcnRTeW1ib2wgPSA8U29ydENhcmV0IG9yZGVyPXsgc29ydE9yZGVyIH0gLz47XG5cbiAgICAgIC8vIGFwcGVuZCBjdXN0b21pemVkIGNsYXNzZXMgb3Igc3R5bGUgaWYgdGFibGUgd2FzIHNvcnRpbmcgYmFzZWQgb24gdGhlIGN1cnJlbnQgY29sdW1uLlxuICAgICAgY2VsbENsYXNzZXMgPSBjcyhcbiAgICAgICAgY2VsbENsYXNzZXMsXG4gICAgICAgIF8uaXNGdW5jdGlvbihoZWFkZXJTb3J0aW5nQ2xhc3NlcylcbiAgICAgICAgICA/IGhlYWRlclNvcnRpbmdDbGFzc2VzKGNvbHVtbiwgc29ydE9yZGVyLCBpc0xhc3RTb3J0aW5nLCBpbmRleClcbiAgICAgICAgICA6IGhlYWRlclNvcnRpbmdDbGFzc2VzXG4gICAgICApO1xuXG4gICAgICBjZWxsU3R5bGUgPSB7XG4gICAgICAgIC4uLmNlbGxTdHlsZSxcbiAgICAgICAgLi4uXy5pc0Z1bmN0aW9uKGhlYWRlclNvcnRpbmdTdHlsZSlcbiAgICAgICAgICA/IGhlYWRlclNvcnRpbmdTdHlsZShjb2x1bW4sIHNvcnRPcmRlciwgaXNMYXN0U29ydGluZywgaW5kZXgpXG4gICAgICAgICAgOiBoZWFkZXJTb3J0aW5nU3R5bGVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvcnRTeW1ib2wgPSA8U29ydFN5bWJvbCAvPjtcbiAgICB9XG4gIH1cblxuICBpZiAoY2VsbENsYXNzZXMpIGNlbGxBdHRycy5jbGFzc05hbWUgPSBjcyhjZWxsQXR0cnMuY2xhc3NOYW1lLCBjZWxsQ2xhc3Nlcyk7XG4gIGlmICghXy5pc0VtcHR5T2JqZWN0KGNlbGxTdHlsZSkpIGNlbGxBdHRycy5zdHlsZSA9IGNlbGxTdHlsZTtcblxuICBpZiAoZmlsdGVyUmVuZGVyZXIpIHtcbiAgICBjb25zdCBvbkN1c3RvbUZpbHRlciA9IG9uRXh0ZXJuYWxGaWx0ZXIoY29sdW1uLCBmaWx0ZXIucHJvcHMudHlwZSk7XG4gICAgZmlsdGVyRWxtID0gZmlsdGVyUmVuZGVyZXIob25DdXN0b21GaWx0ZXIsIGNvbHVtbik7XG4gIH0gZWxzZSBpZiAoZmlsdGVyKSB7XG4gICAgZmlsdGVyRWxtID0gPGZpbHRlci5GaWx0ZXIgeyAuLi5maWx0ZXIucHJvcHMgfSBvbkZpbHRlcj17IG9uRmlsdGVyIH0gY29sdW1uPXsgY29sdW1uIH0gLz47XG4gIH1cblxuICBjb25zdCBjaGlsZHJlbiA9IGhlYWRlckZvcm1hdHRlciA/XG4gICAgaGVhZGVyRm9ybWF0dGVyKGNvbHVtbiwgaW5kZXgsIHsgc29ydEVsZW1lbnQ6IHNvcnRTeW1ib2wsIGZpbHRlckVsZW1lbnQ6IGZpbHRlckVsbSB9KSA6XG4gICAgdGV4dDtcblxuICBpZiAoaGVhZGVyRm9ybWF0dGVyKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3RoJywgY2VsbEF0dHJzLCBjaGlsZHJlbik7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgndGgnLCBjZWxsQXR0cnMsIGNoaWxkcmVuLCBzb3J0U3ltYm9sLCBmaWx0ZXJFbG0pO1xufTtcblxuSGVhZGVyQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIGNvbHVtbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBkYXRhRmllbGQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICB0ZXh0OiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaGlkZGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBoZWFkZXJGb3JtYXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGZvcm1hdHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZm9ybWF0RXh0cmFEYXRhOiBQcm9wVHlwZXMuYW55LFxuICAgIGhlYWRlckNsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgY2xhc3NlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoZWFkZXJTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBzdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoZWFkZXJUaXRsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgdGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGhlYWRlckV2ZW50czogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBldmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgaGVhZGVyQWxpZ246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgYWxpZ246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgaGVhZGVyQXR0cnM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgYXR0cnM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgc29ydDogUHJvcFR5cGVzLmJvb2wsXG4gICAgc29ydEZ1bmM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZWRpdG9yOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGVkaXRhYmxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBlZGl0Q2VsbFN0eWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVkaXRDZWxsQ2xhc3NlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBlZGl0b3JTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBlZGl0b3JDbGFzc2VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVkaXRvclJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB2YWxpZGF0b3I6IFByb3BUeXBlcy5mdW5jLFxuICAgIGZpbHRlcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBmaWx0ZXJSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZmlsdGVyVmFsdWU6IFByb3BUeXBlcy5mdW5jXG4gIH0pLmlzUmVxdWlyZWQsXG4gIGluZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvcnRpbmc6IFByb3BUeXBlcy5ib29sLFxuICBzb3J0T3JkZXI6IFByb3BUeXBlcy5vbmVPZihbQ29uc3QuU09SVF9BU0MsIENvbnN0LlNPUlRfREVTQ10pLFxuICBpc0xhc3RTb3J0aW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25GaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkV4dGVybmFsRmlsdGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyQ2VsbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2hlYWRlci1jZWxsLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgU29ydFN5bWJvbCA9ICgpID0+IChcbiAgPHNwYW4gY2xhc3NOYW1lPVwib3JkZXJcIj5cbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkcm9wZG93blwiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY2FyZXRcIiAvPlxuICAgIDwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkcm9wdXBcIj5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNhcmV0XCIgLz5cbiAgICA8L3NwYW4+XG4gIDwvc3Bhbj4pO1xuXG5leHBvcnQgZGVmYXVsdCBTb3J0U3ltYm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc29ydC9zeW1ib2wuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IENvbnN0IGZyb20gJy4uL2NvbnN0JztcblxuY29uc3QgU29ydENhcmV0ID0gKHsgb3JkZXIgfSkgPT4ge1xuICBjb25zdCBvcmRlckNsYXNzID0gY3MoJ3JlYWN0LWJvb3RzdHJhcC10YWJsZS1zb3J0LW9yZGVyJywge1xuICAgIGRyb3B1cDogb3JkZXIgPT09IENvbnN0LlNPUlRfQVNDXG4gIH0pO1xuICByZXR1cm4gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT17IG9yZGVyQ2xhc3MgfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNhcmV0XCIgLz5cbiAgICA8L3NwYW4+XG4gICk7XG59O1xuXG5Tb3J0Q2FyZXQucHJvcFR5cGVzID0ge1xuICBvcmRlcjogUHJvcFR5cGVzLm9uZU9mKFtDb25zdC5TT1JUX0FTQywgQ29uc3QuU09SVF9ERVNDXSkuaXNSZXF1aXJlZFxufTtcbmV4cG9ydCBkZWZhdWx0IFNvcnRDYXJldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3NvcnQvY2FyZXQuanMiLCIvKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi9jb25zdCc7XG5cbmV4cG9ydCBjb25zdCBDaGVja0JveCA9ICh7IGNoZWNrZWQsIGluZGV0ZXJtaW5hdGUgfSkgPT4gKFxuICA8aW5wdXRcbiAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgIGNoZWNrZWQ9eyBjaGVja2VkIH1cbiAgICByZWY9eyAoaW5wdXQpID0+IHtcbiAgICAgIGlmIChpbnB1dCkgaW5wdXQuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB9IH1cbiAgLz5cbik7XG5cbkNoZWNrQm94LnByb3BUeXBlcyA9IHtcbiAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0aW9uSGVhZGVyQ2VsbCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgbW9kZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGNoZWNrZWRTdGF0dXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25BbGxSb3dzU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzZWxlY3Rpb25IZWFkZXJSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmNcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5oYW5kbGVDaGVja0JveENsaWNrID0gdGhpcy5oYW5kbGVDaGVja0JveENsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogYXZvaWQgdXBkYXRpbmcgaWYgYnV0dG9uIGlzXG4gICAqIDEuIHJhZGlvXG4gICAqIDIuIHN0YXR1cyB3YXMgbm90IGNoYW5nZWQuXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgY29uc3QgeyBST1dfU0VMRUNUX1NJTkdMRSB9ID0gQ29uc3Q7XG4gICAgY29uc3QgeyBtb2RlLCBjaGVja2VkU3RhdHVzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKG1vZGUgPT09IFJPV19TRUxFQ1RfU0lOR0xFKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gbmV4dFByb3BzLmNoZWNrZWRTdGF0dXMgIT09IGNoZWNrZWRTdGF0dXM7XG4gIH1cblxuICBoYW5kbGVDaGVja0JveENsaWNrKGUpIHtcbiAgICBjb25zdCB7IG9uQWxsUm93c1NlbGVjdCB9ID0gdGhpcy5wcm9wcztcblxuICAgIG9uQWxsUm93c1NlbGVjdChlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRCwgQ0hFQ0tCT1hfU1RBVFVTX0lOREVURVJNSU5BVEUsIFJPV19TRUxFQ1RfTVVMVElQTEVcbiAgICB9ID0gQ29uc3Q7XG5cbiAgICBjb25zdCB7IG1vZGUsIGNoZWNrZWRTdGF0dXMsIHNlbGVjdGlvbkhlYWRlclJlbmRlcmVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgY2hlY2tlZCA9IGNoZWNrZWRTdGF0dXMgPT09IENIRUNLQk9YX1NUQVRVU19DSEVDS0VEO1xuXG4gICAgY29uc3QgaW5kZXRlcm1pbmF0ZSA9IGNoZWNrZWRTdGF0dXMgPT09IENIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFO1xuXG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBsZXQgY29udGVudDtcbiAgICBpZiAoc2VsZWN0aW9uSGVhZGVyUmVuZGVyZXIpIHtcbiAgICAgIGNvbnRlbnQgPSBzZWxlY3Rpb25IZWFkZXJSZW5kZXJlcih7XG4gICAgICAgIG1vZGUsXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIGluZGV0ZXJtaW5hdGVcbiAgICAgIH0pO1xuICAgICAgYXR0cnMub25DbGljayA9IHRoaXMuaGFuZGxlQ2hlY2tCb3hDbGljaztcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFJPV19TRUxFQ1RfTVVMVElQTEUpIHtcbiAgICAgIGNvbnRlbnQgPSAoXG4gICAgICAgIDxDaGVja0JveFxuICAgICAgICAgIHsgLi4udGhpcy5wcm9wcyB9XG4gICAgICAgICAgY2hlY2tlZD17IGNoZWNrZWQgfVxuICAgICAgICAgIGluZGV0ZXJtaW5hdGU9eyBpbmRldGVybWluYXRlIH1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgICBhdHRycy5vbkNsaWNrID0gdGhpcy5oYW5kbGVDaGVja0JveENsaWNrO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8dGggZGF0YS1yb3ctc2VsZWN0aW9uIHsgLi4uYXR0cnMgfT57IGNvbnRlbnQgfTwvdGg+XG4gICAgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwuanMiLCIvKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY29uc3QgQ2FwdGlvbiA9IChwcm9wcykgPT4ge1xuICBpZiAoIXByb3BzLmNoaWxkcmVuKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIChcbiAgICA8Y2FwdGlvbj57IHByb3BzLmNoaWxkcmVuIH08L2NhcHRpb24+XG4gICk7XG59O1xuXG5DYXB0aW9uLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5ub2RlLFxuICAgIFByb3BUeXBlcy5zdHJpbmdcbiAgXSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENhcHRpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jYXB0aW9uLmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IFJvdyBmcm9tICcuL3Jvdyc7XG5pbXBvcnQgUm93U2VjdGlvbiBmcm9tICcuL3Jvdy1zZWN0aW9uJztcbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcblxuY29uc3QgQm9keSA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgY29sdW1ucyxcbiAgICBkYXRhLFxuICAgIGtleUZpZWxkLFxuICAgIGlzRW1wdHksXG4gICAgbm9EYXRhSW5kaWNhdGlvbixcbiAgICB2aXNpYmxlQ29sdW1uU2l6ZSxcbiAgICBjZWxsRWRpdCxcbiAgICBzZWxlY3RSb3csXG4gICAgc2VsZWN0ZWRSb3dLZXlzLFxuICAgIHJvd1N0eWxlLFxuICAgIHJvd0NsYXNzZXMsXG4gICAgcm93RXZlbnRzXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCB7XG4gICAgYmdDb2xvcixcbiAgICBub25TZWxlY3RhYmxlXG4gIH0gPSBzZWxlY3RSb3c7XG5cbiAgbGV0IGNvbnRlbnQ7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICBjb25zdCBpbmRpY2F0aW9uID0gXy5pc0Z1bmN0aW9uKG5vRGF0YUluZGljYXRpb24pID8gbm9EYXRhSW5kaWNhdGlvbigpIDogbm9EYXRhSW5kaWNhdGlvbjtcbiAgICBpZiAoIWluZGljYXRpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb250ZW50ID0gPFJvd1NlY3Rpb24gY29udGVudD17IGluZGljYXRpb24gfSBjb2xTcGFuPXsgdmlzaWJsZUNvbHVtblNpemUgfSAvPjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub25FZGl0YWJsZVJvd3MgPSBjZWxsRWRpdC5ub25FZGl0YWJsZVJvd3MgfHwgW107XG4gICAgY29udGVudCA9IGRhdGEubWFwKChyb3csIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBfLmdldChyb3csIGtleUZpZWxkKTtcbiAgICAgIGNvbnN0IGVkaXRhYmxlID0gIShub25FZGl0YWJsZVJvd3MubGVuZ3RoID4gMCAmJiBub25FZGl0YWJsZVJvd3MuaW5kZXhPZihrZXkpID4gLTEpO1xuXG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdFJvdy5tb2RlICE9PSBDb25zdC5ST1dfU0VMRUNUX0RJU0FCTEVEXG4gICAgICAgID8gc2VsZWN0ZWRSb3dLZXlzLmluY2x1ZGVzKGtleSlcbiAgICAgICAgOiBudWxsO1xuXG4gICAgICBjb25zdCBhdHRycyA9IHJvd0V2ZW50cyB8fCB7fTtcbiAgICAgIGxldCBzdHlsZSA9IF8uaXNGdW5jdGlvbihyb3dTdHlsZSkgPyByb3dTdHlsZShyb3csIGluZGV4KSA6IHJvd1N0eWxlO1xuICAgICAgbGV0IGNsYXNzZXMgPSAoXy5pc0Z1bmN0aW9uKHJvd0NsYXNzZXMpID8gcm93Q2xhc3Nlcyhyb3csIGluZGV4KSA6IHJvd0NsYXNzZXMpO1xuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkU3R5bGUgPSBfLmlzRnVuY3Rpb24oc2VsZWN0Um93LnN0eWxlKVxuICAgICAgICAgID8gc2VsZWN0Um93LnN0eWxlKHJvdywgaW5kZXgpXG4gICAgICAgICAgOiBzZWxlY3RSb3cuc3R5bGU7XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDbGFzc2VzID0gXy5pc0Z1bmN0aW9uKHNlbGVjdFJvdy5jbGFzc2VzKVxuICAgICAgICAgID8gc2VsZWN0Um93LmNsYXNzZXMocm93LCBpbmRleClcbiAgICAgICAgICA6IHNlbGVjdFJvdy5jbGFzc2VzO1xuXG4gICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgIC4uLnNlbGVjdGVkU3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NlcyA9IGNzKGNsYXNzZXMsIHNlbGVjdGVkQ2xhc3Nlcyk7XG5cbiAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IF8uaXNGdW5jdGlvbihiZ0NvbG9yKSA/IGJnQ29sb3Iocm93LCBpbmRleCkgOiBiZ0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGFibGUgPSAhbm9uU2VsZWN0YWJsZSB8fCAhbm9uU2VsZWN0YWJsZS5pbmNsdWRlcyhrZXkpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Um93XG4gICAgICAgICAga2V5PXsga2V5IH1cbiAgICAgICAgICByb3c9eyByb3cgfVxuICAgICAgICAgIGtleUZpZWxkPXsga2V5RmllbGQgfVxuICAgICAgICAgIHJvd0luZGV4PXsgaW5kZXggfVxuICAgICAgICAgIGNvbHVtbnM9eyBjb2x1bW5zIH1cbiAgICAgICAgICBjZWxsRWRpdD17IGNlbGxFZGl0IH1cbiAgICAgICAgICBlZGl0YWJsZT17IGVkaXRhYmxlIH1cbiAgICAgICAgICBzZWxlY3RhYmxlPXsgc2VsZWN0YWJsZSB9XG4gICAgICAgICAgc2VsZWN0ZWQ9eyBzZWxlY3RlZCB9XG4gICAgICAgICAgc2VsZWN0Um93PXsgc2VsZWN0Um93IH1cbiAgICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgICAgICBjbGFzc05hbWU9eyBjbGFzc2VzIH1cbiAgICAgICAgICBhdHRycz17IGF0dHJzIH1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDx0Ym9keT57IGNvbnRlbnQgfTwvdGJvZHk+XG4gICk7XG59O1xuXG5Cb2R5LnByb3BUeXBlcyA9IHtcbiAga2V5RmllbGQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBzZWxlY3RSb3c6IFByb3BUeXBlcy5vYmplY3QsXG4gIHNlbGVjdGVkUm93S2V5czogUHJvcFR5cGVzLmFycmF5XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCb2R5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvYm9keS5qcyIsIi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG4vKiBlc2xpbnQgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5OiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IF8gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL2NlbGwnO1xuaW1wb3J0IFNlbGVjdGlvbkNlbGwgZnJvbSAnLi9yb3ctc2VsZWN0aW9uL3NlbGVjdGlvbi1jZWxsJztcbmltcG9ydCBldmVudERlbGVnYXRlciBmcm9tICcuL3Jvdy1ldmVudC1kZWxlZ2F0ZXInO1xuaW1wb3J0IENvbnN0IGZyb20gJy4vY29uc3QnO1xuXG5jbGFzcyBSb3cgZXh0ZW5kcyBldmVudERlbGVnYXRlcihDb21wb25lbnQpIHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdyxcbiAgICAgIGNvbHVtbnMsXG4gICAgICBrZXlGaWVsZCxcbiAgICAgIHJvd0luZGV4LFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgc3R5bGUsXG4gICAgICBhdHRycyxcbiAgICAgIGNlbGxFZGl0LFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICBzZWxlY3RSb3csXG4gICAgICBzZWxlY3RhYmxlLFxuICAgICAgZWRpdGFibGU6IGVkaXRhYmxlUm93XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7XG4gICAgICBtb2RlLFxuICAgICAgb25TdGFydCxcbiAgICAgIEVkaXRpbmdDZWxsLFxuICAgICAgcmlkeDogZWRpdGluZ1Jvd0lkeCxcbiAgICAgIGNpZHg6IGVkaXRpbmdDb2xJZHgsXG4gICAgICBDTElDS19UT19DRUxMX0VESVQsXG4gICAgICBEQkNMSUNLX1RPX0NFTExfRURJVCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gY2VsbEVkaXQ7XG5cbiAgICBjb25zdCBrZXkgPSBfLmdldChyb3csIGtleUZpZWxkKTtcbiAgICBjb25zdCB7IGhpZGVTZWxlY3RDb2x1bW4gfSA9IHNlbGVjdFJvdztcbiAgICBjb25zdCB0ckF0dHJzID0gdGhpcy5kZWxlZ2F0ZShhdHRycyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRyIHN0eWxlPXsgc3R5bGUgfSBjbGFzc05hbWU9eyBjbGFzc05hbWUgfSB7IC4uLnRyQXR0cnMgfT5cbiAgICAgICAge1xuICAgICAgICAgIChzZWxlY3RSb3cubW9kZSAhPT0gQ29uc3QuUk9XX1NFTEVDVF9ESVNBQkxFRCAmJiAhaGlkZVNlbGVjdENvbHVtbilcbiAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICA8U2VsZWN0aW9uQ2VsbFxuICAgICAgICAgICAgICAgIHsgLi4uc2VsZWN0Um93IH1cbiAgICAgICAgICAgICAgICByb3dLZXk9eyBrZXkgfVxuICAgICAgICAgICAgICAgIHJvd0luZGV4PXsgcm93SW5kZXggfVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkPXsgc2VsZWN0ZWQgfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXsgIXNlbGVjdGFibGUgfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGNvbHVtbnMubWFwKChjb2x1bW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbHVtbi5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhRmllbGQgfSA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IF8uZ2V0KHJvdywgZGF0YUZpZWxkKTtcbiAgICAgICAgICAgICAgbGV0IGVkaXRhYmxlID0gXy5pc0RlZmluZWQoY29sdW1uLmVkaXRhYmxlKSA/IGNvbHVtbi5lZGl0YWJsZSA6IHRydWU7XG4gICAgICAgICAgICAgIGlmIChkYXRhRmllbGQgPT09IGtleUZpZWxkIHx8ICFlZGl0YWJsZVJvdykgZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uZWRpdGFibGUpKSB7XG4gICAgICAgICAgICAgICAgZWRpdGFibGUgPSBjb2x1bW4uZWRpdGFibGUoY29udGVudCwgcm93LCByb3dJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyb3dJbmRleCA9PT0gZWRpdGluZ1Jvd0lkeCAmJiBpbmRleCA9PT0gZWRpdGluZ0NvbElkeCkge1xuICAgICAgICAgICAgICAgIGxldCBlZGl0Q2VsbHN0eWxlID0gY29sdW1uLmVkaXRDZWxsU3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgbGV0IGVkaXRDZWxsY2xhc3NlcyA9IGNvbHVtbi5lZGl0Q2VsbENsYXNzZXM7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uZWRpdENlbGxTdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgIGVkaXRDZWxsc3R5bGUgPSBjb2x1bW4uZWRpdENlbGxTdHlsZShjb250ZW50LCByb3csIHJvd0luZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY29sdW1uLmVkaXRDZWxsQ2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICAgIGVkaXRDZWxsY2xhc3NlcyA9IGNvbHVtbi5lZGl0Q2VsbENsYXNzZXMoY29udGVudCwgcm93LCByb3dJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgPEVkaXRpbmdDZWxsXG4gICAgICAgICAgICAgICAgICAgIGtleT17IGAke2NvbnRlbnR9LSR7aW5kZXh9YCB9XG4gICAgICAgICAgICAgICAgICAgIHJvdz17IHJvdyB9XG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4PXsgcm93SW5kZXggfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW49eyBjb2x1bW4gfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleD17IGluZGV4IH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXsgZWRpdENlbGxjbGFzc2VzIH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9eyBlZGl0Q2VsbHN0eWxlIH1cbiAgICAgICAgICAgICAgICAgICAgeyAuLi5yZXN0IH1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxDZWxsXG4gICAgICAgICAgICAgICAgICBrZXk9eyBgJHtjb250ZW50fS0ke2luZGV4fWAgfVxuICAgICAgICAgICAgICAgICAgcm93PXsgcm93IH1cbiAgICAgICAgICAgICAgICAgIHJvd0luZGV4PXsgcm93SW5kZXggfVxuICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXg9eyBpbmRleCB9XG4gICAgICAgICAgICAgICAgICBjb2x1bW49eyBjb2x1bW4gfVxuICAgICAgICAgICAgICAgICAgb25TdGFydD17IG9uU3RhcnQgfVxuICAgICAgICAgICAgICAgICAgZWRpdGFibGU9eyBlZGl0YWJsZSB9XG4gICAgICAgICAgICAgICAgICBjbGlja1RvRWRpdD17IG1vZGUgPT09IENMSUNLX1RPX0NFTExfRURJVCB9XG4gICAgICAgICAgICAgICAgICBkYmNsaWNrVG9FZGl0PXsgbW9kZSA9PT0gREJDTElDS19UT19DRUxMX0VESVQgfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgPC90cj5cbiAgICApO1xuICB9XG59XG5cblJvdy5wcm9wVHlwZXMgPSB7XG4gIHJvdzogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICByb3dJbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYXR0cnM6IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cblJvdy5kZWZhdWx0UHJvcHMgPSB7XG4gIGVkaXRhYmxlOiB0cnVlLFxuICBzdHlsZToge30sXG4gIGNsYXNzTmFtZTogbnVsbCxcbiAgYXR0cnM6IHt9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSb3c7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3cuanMiLCIvKiBlc2xpbnQgcmVhY3QvcHJvcC10eXBlczogMCAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuXG5jbGFzcyBDZWxsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5oYW5kbGVFZGl0aW5nQ2VsbCA9IHRoaXMuaGFuZGxlRWRpdGluZ0NlbGwuYmluZCh0aGlzKTtcbiAgfVxuXG4gIGhhbmRsZUVkaXRpbmdDZWxsKGUpIHtcbiAgICBjb25zdCB7IGNvbHVtbiwgb25TdGFydCwgcm93SW5kZXgsIGNvbHVtbkluZGV4LCBjbGlja1RvRWRpdCwgZGJjbGlja1RvRWRpdCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGV2ZW50cyB9ID0gY29sdW1uO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGlmIChjbGlja1RvRWRpdCkge1xuICAgICAgICBjb25zdCBjdXN0b21DbGljayA9IGV2ZW50cy5vbkNsaWNrO1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGN1c3RvbUNsaWNrKSkgY3VzdG9tQ2xpY2soZSk7XG4gICAgICB9IGVsc2UgaWYgKGRiY2xpY2tUb0VkaXQpIHtcbiAgICAgICAgY29uc3QgY3VzdG9tRGJDbGljayA9IGV2ZW50cy5vbkRvdWJsZUNsaWNrO1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGN1c3RvbURiQ2xpY2spKSBjdXN0b21EYkNsaWNrKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25TdGFydCkge1xuICAgICAgb25TdGFydChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICByb3csXG4gICAgICByb3dJbmRleCxcbiAgICAgIGNvbHVtbixcbiAgICAgIGNvbHVtbkluZGV4LFxuICAgICAgZWRpdGFibGUsXG4gICAgICBjbGlja1RvRWRpdCxcbiAgICAgIGRiY2xpY2tUb0VkaXRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBkYXRhRmllbGQsXG4gICAgICBmb3JtYXR0ZXIsXG4gICAgICBmb3JtYXRFeHRyYURhdGEsXG4gICAgICBzdHlsZSxcbiAgICAgIGNsYXNzZXMsXG4gICAgICB0aXRsZSxcbiAgICAgIGV2ZW50cyxcbiAgICAgIGFsaWduLFxuICAgICAgYXR0cnNcbiAgICB9ID0gY29sdW1uO1xuICAgIGxldCBjZWxsVGl0bGU7XG4gICAgbGV0IGNlbGxTdHlsZSA9IHt9O1xuICAgIGxldCBjb250ZW50ID0gXy5nZXQocm93LCBkYXRhRmllbGQpO1xuXG4gICAgY29uc3QgY2VsbEF0dHJzID0ge1xuICAgICAgLi4uXy5pc0Z1bmN0aW9uKGF0dHJzKSA/IGF0dHJzKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGNvbHVtbkluZGV4KSA6IGF0dHJzLFxuICAgICAgLi4uZXZlbnRzXG4gICAgfTtcblxuICAgIGNvbnN0IGNlbGxDbGFzc2VzID0gXy5pc0Z1bmN0aW9uKGNsYXNzZXMpXG4gICAgICA/IGNsYXNzZXMoY29udGVudCwgcm93LCByb3dJbmRleCwgY29sdW1uSW5kZXgpXG4gICAgICA6IGNsYXNzZXM7XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGNlbGxTdHlsZSA9IF8uaXNGdW5jdGlvbihzdHlsZSkgPyBzdHlsZShjb250ZW50LCByb3csIHJvd0luZGV4LCBjb2x1bW5JbmRleCkgOiBzdHlsZTtcbiAgICB9XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNlbGxUaXRsZSA9IF8uaXNGdW5jdGlvbih0aXRsZSkgPyB0aXRsZShjb250ZW50LCByb3csIHJvd0luZGV4LCBjb2x1bW5JbmRleCkgOiBjb250ZW50O1xuICAgICAgY2VsbEF0dHJzLnRpdGxlID0gY2VsbFRpdGxlO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIGNvbnRlbnQgPSBjb2x1bW4uZm9ybWF0dGVyKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGZvcm1hdEV4dHJhRGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKGFsaWduKSB7XG4gICAgICBjZWxsU3R5bGUudGV4dEFsaWduID1cbiAgICAgICAgXy5pc0Z1bmN0aW9uKGFsaWduKSA/IGFsaWduKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGNvbHVtbkluZGV4KSA6IGFsaWduO1xuICAgIH1cblxuICAgIGlmIChjZWxsQ2xhc3NlcykgY2VsbEF0dHJzLmNsYXNzTmFtZSA9IGNlbGxDbGFzc2VzO1xuXG4gICAgaWYgKCFfLmlzRW1wdHlPYmplY3QoY2VsbFN0eWxlKSkgY2VsbEF0dHJzLnN0eWxlID0gY2VsbFN0eWxlO1xuICAgIGlmIChjbGlja1RvRWRpdCAmJiBlZGl0YWJsZSkge1xuICAgICAgY2VsbEF0dHJzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUVkaXRpbmdDZWxsO1xuICAgIH0gZWxzZSBpZiAoZGJjbGlja1RvRWRpdCAmJiBlZGl0YWJsZSkge1xuICAgICAgY2VsbEF0dHJzLm9uRG91YmxlQ2xpY2sgPSB0aGlzLmhhbmRsZUVkaXRpbmdDZWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPHRkIHsgLi4uY2VsbEF0dHJzIH0+XG4gICAgICAgIHsgdHlwZW9mIGNvbnRlbnQgPT09ICdib29sZWFuJyA/IGAke2NvbnRlbnR9YCA6IGNvbnRlbnQgfVxuICAgICAgPC90ZD5cbiAgICApO1xuICB9XG59XG5cbkNlbGwucHJvcFR5cGVzID0ge1xuICByb3c6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY29sdW1uOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNvbHVtbkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENlbGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jZWxsLmpzIiwiLyogZXNsaW50XG4gIHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMFxuICBqc3gtYTExeS9uby1ub25pbnRlcmFjdGl2ZS1lbGVtZW50LWludGVyYWN0aW9uczogMFxuKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL2NvbnN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0aW9uQ2VsbCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgbW9kZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHJvd0tleTogUHJvcFR5cGVzLmFueSxcbiAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25Sb3dTZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICByb3dJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBjbGlja1RvU2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzZWxlY3Rpb25SZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmNcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5oYW5kbGVDbGljayA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICBjb25zdCB7IHNlbGVjdGVkIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIG5leHRQcm9wcy5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQ7XG4gIH1cblxuICBoYW5kbGVDbGljayhlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbW9kZTogaW5wdXRUeXBlLFxuICAgICAgcm93S2V5LFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICBvblJvd1NlbGVjdCxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgcm93SW5kZXgsXG4gICAgICBjbGlja1RvU2VsZWN0XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoY2xpY2tUb1NlbGVjdCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2hlY2tlZCA9IGlucHV0VHlwZSA9PT0gQ29uc3QuUk9XX1NFTEVDVF9TSU5HTEVcbiAgICAgID8gdHJ1ZVxuICAgICAgOiAhc2VsZWN0ZWQ7XG5cbiAgICBvblJvd1NlbGVjdChyb3dLZXksIGNoZWNrZWQsIHJvd0luZGV4LCBlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtb2RlOiBpbnB1dFR5cGUsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgc2VsZWN0aW9uUmVuZGVyZXJcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8dGQgb25DbGljaz17IHRoaXMuaGFuZGxlQ2xpY2sgfT5cbiAgICAgICAge1xuICAgICAgICAgIHNlbGVjdGlvblJlbmRlcmVyID8gc2VsZWN0aW9uUmVuZGVyZXIoe1xuICAgICAgICAgICAgbW9kZTogaW5wdXRUeXBlLFxuICAgICAgICAgICAgY2hlY2tlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICAgIH0pIDogKFxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9eyBpbnB1dFR5cGUgfVxuICAgICAgICAgICAgICBjaGVja2VkPXsgc2VsZWN0ZWQgfVxuICAgICAgICAgICAgICBkaXNhYmxlZD17IGRpc2FibGVkIH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICA8L3RkPlxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWNlbGwuanMiLCJpbXBvcnQgXyBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgZXZlbnRzID0gW1xuICAnb25DbGljaycsXG4gICdvbkRvdWJsZUNsaWNrJyxcbiAgJ29uTW91c2VFbnRlcicsXG4gICdvbk1vdXNlTGVhdmUnXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbmRCYXNlID0+XG4gIGNsYXNzIFJvd0V2ZW50RGVsZWdhdGVyIGV4dGVuZHMgRXh0ZW5kQmFzZSB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgIHRoaXMuY2xpY2tOdW0gPSAwO1xuICAgICAgdGhpcy5jcmVhdGVEZWZhdWx0RXZlbnRIYW5kbGVyID0gdGhpcy5jcmVhdGVEZWZhdWx0RXZlbnRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNyZWF0ZUNsaWNrRXZlbnRIYW5kbGVyID0gdGhpcy5jcmVhdGVDbGlja0V2ZW50SGFuZGxlci5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlZmF1bHRFdmVudEhhbmRsZXIoY2IpIHtcbiAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHJvdywgcm93SW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNiKGUsIHJvdywgcm93SW5kZXgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGlja0V2ZW50SGFuZGxlcihjYikge1xuICAgICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByb3csXG4gICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAga2V5RmllbGQsXG4gICAgICAgICAgc2VsZWN0YWJsZSxcbiAgICAgICAgICByb3dJbmRleCxcbiAgICAgICAgICBzZWxlY3RSb3c6IHtcbiAgICAgICAgICAgIG9uUm93U2VsZWN0LFxuICAgICAgICAgICAgY2xpY2tUb0VkaXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNlbGxFZGl0OiB7XG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgREJDTElDS19UT19DRUxMX0VESVQsXG4gICAgICAgICAgICBERUxBWV9GT1JfREJDTElDS1xuICAgICAgICAgIH1cbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgY2xpY2tGbiA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKGUsIHJvdywgcm93SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gXy5nZXQocm93LCBrZXlGaWVsZCk7XG4gICAgICAgICAgICBvblJvd1NlbGVjdChrZXksICFzZWxlY3RlZCwgcm93SW5kZXgsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobW9kZSA9PT0gREJDTElDS19UT19DRUxMX0VESVQgJiYgY2xpY2tUb0VkaXQpIHtcbiAgICAgICAgICB0aGlzLmNsaWNrTnVtICs9IDE7XG4gICAgICAgICAgXy5kZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGlja051bSA9PT0gMSkge1xuICAgICAgICAgICAgICBjbGlja0ZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsaWNrTnVtID0gMDtcbiAgICAgICAgICB9LCBERUxBWV9GT1JfREJDTElDSykoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGlja0ZuKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVsZWdhdGUoYXR0cnMgPSB7fSkge1xuICAgICAgY29uc3QgbmV3QXR0cnMgPSB7fTtcbiAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdFJvdyAmJiB0aGlzLnByb3BzLnNlbGVjdFJvdy5jbGlja1RvU2VsZWN0KSB7XG4gICAgICAgIG5ld0F0dHJzLm9uQ2xpY2sgPSB0aGlzLmNyZWF0ZUNsaWNrRXZlbnRIYW5kbGVyKGF0dHJzLm9uQ2xpY2spO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgICAgaWYgKCFuZXdBdHRyc1thdHRyXSkge1xuICAgICAgICAgIGlmIChldmVudHMuaW5jbHVkZXMoYXR0cikpIHtcbiAgICAgICAgICAgIG5ld0F0dHJzW2F0dHJdID0gdGhpcy5jcmVhdGVEZWZhdWx0RXZlbnRIYW5kbGVyKGF0dHJzW2F0dHJdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3QXR0cnNbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ld0F0dHJzO1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1ldmVudC1kZWxlZ2F0ZXIuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY29uc3QgUm93U2VjdGlvbiA9ICh7IGNvbnRlbnQsIGNvbFNwYW4gfSkgPT4gKFxuICA8dHI+XG4gICAgPHRkXG4gICAgICBkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJcbiAgICAgIGNvbFNwYW49eyBjb2xTcGFuIH1cbiAgICAgIGNsYXNzTmFtZT1cInJlYWN0LWJzLXRhYmxlLW5vLWRhdGFcIlxuICAgID5cbiAgICAgIHsgY29udGVudCB9XG4gICAgPC90ZD5cbiAgPC90cj5cbik7XG5cblJvd1NlY3Rpb24ucHJvcFR5cGVzID0ge1xuICBjb250ZW50OiBQcm9wVHlwZXMuYW55LFxuICBjb2xTcGFuOiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG5Sb3dTZWN0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgY29udGVudDogbnVsbCxcbiAgY29sU3BhbjogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUm93U2VjdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWN0aW9uLmpzIiwiaW1wb3J0IENvbHVtblJlc29sdmVyIGZyb20gJy4vY29sdW1uLXJlc29sdmVyJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi9jb25zdCc7XG5pbXBvcnQgXyBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuZEJhc2UgPT5cbiAgY2xhc3MgVGFibGVSZXNvbHZlciBleHRlbmRzIENvbHVtblJlc29sdmVyKEV4dGVuZEJhc2UpIHtcbiAgICB2YWxpZGF0ZVByb3BzKCkge1xuICAgICAgY29uc3QgeyBrZXlGaWVsZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICgha2V5RmllbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSBhIGZpZWxkIGFzIGtleSB2aWEga2V5RmllbGQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnZpc2libGVDb2x1bW5TaXplKGZhbHNlKSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmlzaWJsZSBjb2x1bW5zIGRldGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmRhdGEubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb3BzIHJlc29sdmVyIGZvciBjZWxsIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkdGlvbmFsIG9wdGlvbnMgbGlrZSBjYWxsYmFjayB3aGljaCBhcmUgYWJvdXQgdG8gbWVyZ2UgaW50byBwcm9wc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVzdWx0IC0gcHJvcHMgZm9yIGNlbGwgc2VsZWN0aW9uc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdC5tb2RlIC0gaW5wdXQgdHlwZSBvZiByb3cgc2VsZWN0aW9uIG9yIGRpc2FibGVkLlxuICAgICAqL1xuICAgIHJlc29sdmVTZWxlY3RSb3dQcm9wcyhvcHRpb25zKSB7XG4gICAgICBjb25zdCB7IHNlbGVjdFJvdyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgUk9XX1NFTEVDVF9ESVNBQkxFRCB9ID0gQ29uc3Q7XG5cbiAgICAgIGlmIChfLmlzRGVmaW5lZChzZWxlY3RSb3cpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2VsZWN0Um93LFxuICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kZTogUk9XX1NFTEVDVF9ESVNBQkxFRFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9wcyByZXNvbHZlciBmb3IgaGVhZGVyIGNlbGwgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhZGR0aW9uYWwgb3B0aW9ucyBsaWtlIGNhbGxiYWNrIHdoaWNoIGFyZSBhYm91dCB0byBtZXJnZSBpbnRvIHByb3BzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXN1bHQgLSBwcm9wcyBmb3IgY2VsbCBzZWxlY3Rpb25zXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0Lm1vZGUgLSBpbnB1dCB0eXBlIG9mIHJvdyBzZWxlY3Rpb24gb3IgZGlzYWJsZWQuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0LmNoZWNrZWRTdGF0dXMgLSBjaGVja2JveCBzdGF0dXMgZGVwZW5kaW5nIG9uIHNlbGVjdGVkIHJvd3MgY291bnRzXG4gICAgICovXG4gICAgcmVzb2x2ZVNlbGVjdFJvd1Byb3BzRm9ySGVhZGVyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgY29uc3QgeyBzZWxlY3RSb3cgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IGFsbFJvd3NTZWxlY3RlZCwgc2VsZWN0ZWQgPSBbXSwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgUk9XX1NFTEVDVF9ESVNBQkxFRCwgQ0hFQ0tCT1hfU1RBVFVTX0NIRUNLRUQsXG4gICAgICAgIENIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFLCBDSEVDS0JPWF9TVEFUVVNfVU5DSEVDS0VEXG4gICAgICB9ID0gQ29uc3Q7XG5cbiAgICAgIGlmIChfLmlzRGVmaW5lZChzZWxlY3RSb3cpKSB7XG4gICAgICAgIGxldCBjaGVja2VkU3RhdHVzO1xuXG4gICAgICAgIC8vIGNoZWNrYm94IHN0YXR1cyBkZXBlbmRpbmcgb24gc2VsZWN0ZWQgcm93cyBjb3VudHNcbiAgICAgICAgaWYgKGFsbFJvd3NTZWxlY3RlZCkgY2hlY2tlZFN0YXR1cyA9IENIRUNLQk9YX1NUQVRVU19DSEVDS0VEO1xuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDApIGNoZWNrZWRTdGF0dXMgPSBDSEVDS0JPWF9TVEFUVVNfVU5DSEVDS0VEO1xuICAgICAgICBlbHNlIGNoZWNrZWRTdGF0dXMgPSBDSEVDS0JPWF9TVEFUVVNfSU5ERVRFUk1JTkFURTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnNlbGVjdFJvdyxcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIGNoZWNrZWRTdGF0dXNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kZTogUk9XX1NFTEVDVF9ESVNBQkxFRFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9pbmRleC5qcyIsImV4cG9ydCBkZWZhdWx0IEV4dGVuZEJhc2UgPT5cbiAgY2xhc3MgQ29sdW1uUmVzb2x2ZXIgZXh0ZW5kcyBFeHRlbmRCYXNlIHtcbiAgICB2aXNpYmxlQ29sdW1uU2l6ZShpbmNsdWRlU2VsZWN0Q29sdW1uID0gdHJ1ZSkge1xuICAgICAgY29uc3QgY29sdW1uTGVuID0gdGhpcy5wcm9wcy5jb2x1bW5zLmZpbHRlcihjID0+ICFjLmhpZGRlbikubGVuZ3RoO1xuICAgICAgaWYgKCFpbmNsdWRlU2VsZWN0Q29sdW1uKSByZXR1cm4gY29sdW1uTGVuO1xuICAgICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0Um93ICYmICF0aGlzLnByb3BzLnNlbGVjdFJvdy5oaWRlU2VsZWN0Q29sdW1uKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5MZW4gKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbkxlbjtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9jb2x1bW4tcmVzb2x2ZXIuanMiLCIvKiBlc2xpbnQgbm8tcmV0dXJuLWFzc2lnbjogMCAqL1xuLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU3RvcmUgZnJvbSAnLi9zdG9yZSc7XG5pbXBvcnQgd2l0aFNvcnQgZnJvbSAnLi9zb3J0L3dyYXBwZXInO1xuaW1wb3J0IHdpdGhTZWxlY3Rpb24gZnJvbSAnLi9yb3ctc2VsZWN0aW9uL3dyYXBwZXInO1xuXG5pbXBvcnQgcmVtb3RlUmVzb2x2ZXIgZnJvbSAnLi9wcm9wcy1yZXNvbHZlci9yZW1vdGUtcmVzb2x2ZXInO1xuaW1wb3J0IF8gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IHdpdGhEYXRhU3RvcmUgPSBCYXNlID0+XG4gIGNsYXNzIEJvb3RzdHJhcFRhYmxlQ29udGFpbmVyIGV4dGVuZHMgcmVtb3RlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgIHRoaXMuc3RvcmUgPSBuZXcgU3RvcmUocHJvcHMua2V5RmllbGQpO1xuICAgICAgdGhpcy5zdG9yZS5kYXRhID0gcHJvcHMuZGF0YTtcbiAgICAgIHRoaXMud3JhcENvbXBvbmVudHMoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdGhpcy5zdG9yZS5zZXRBbGxEYXRhKG5leHRQcm9wcy5kYXRhKTtcbiAgICB9XG5cbiAgICB3cmFwQ29tcG9uZW50cygpIHtcbiAgICAgIHRoaXMuQmFzZUNvbXBvbmVudCA9IEJhc2U7XG4gICAgICBjb25zdCB7IHBhZ2luYXRpb24sIGNvbHVtbnMsIGZpbHRlciwgc2VsZWN0Um93LCBjZWxsRWRpdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmIChwYWdpbmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgd3JhcHBlckZhY3RvcnkgfSA9IHBhZ2luYXRpb247XG4gICAgICAgIHRoaXMuQmFzZUNvbXBvbmVudCA9IHdyYXBwZXJGYWN0b3J5KHRoaXMuQmFzZUNvbXBvbmVudCwge1xuICAgICAgICAgIHJlbW90ZVJlc29sdmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sdW1ucy5maWx0ZXIoY29sID0+IGNvbC5zb3J0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuQmFzZUNvbXBvbmVudCA9IHdpdGhTb3J0KHRoaXMuQmFzZUNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgeyB3cmFwcGVyRmFjdG9yeSB9ID0gZmlsdGVyO1xuICAgICAgICB0aGlzLkJhc2VDb21wb25lbnQgPSB3cmFwcGVyRmFjdG9yeSh0aGlzLkJhc2VDb21wb25lbnQsIHtcbiAgICAgICAgICBfLFxuICAgICAgICAgIHJlbW90ZVJlc29sdmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2VsbEVkaXQpIHtcbiAgICAgICAgY29uc3QgeyB3cmFwcGVyRmFjdG9yeSB9ID0gY2VsbEVkaXQ7XG4gICAgICAgIHRoaXMuQmFzZUNvbXBvbmVudCA9IHdyYXBwZXJGYWN0b3J5KHRoaXMuQmFzZUNvbXBvbmVudCwge1xuICAgICAgICAgIF8sXG4gICAgICAgICAgcmVtb3RlUmVzb2x2ZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RSb3cpIHtcbiAgICAgICAgdGhpcy5CYXNlQ29tcG9uZW50ID0gd2l0aFNlbGVjdGlvbih0aGlzLkJhc2VDb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IGJhc2VQcm9wcyA9IHtcbiAgICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgICAgc3RvcmU6IHRoaXMuc3RvcmVcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDx0aGlzLkJhc2VDb21wb25lbnQgeyAuLi5iYXNlUHJvcHMgfSAvPlxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhEYXRhU3RvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250YWluZXIuanMiLCIvKiBlc2xpbnQgbm8tdW5kZXJzY29yZS1kYW5nbGU6IDAgKi9cbmltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHNvcnQsIG5leHRPcmRlciB9IGZyb20gJy4vc29ydCc7XG5pbXBvcnQgeyBnZXRSb3dCeVJvd0lkIH0gZnJvbSAnLi9yb3dzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmUge1xuICBjb25zdHJ1Y3RvcihrZXlGaWVsZCkge1xuICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB0aGlzLl9maWx0ZXJlZERhdGEgPSBbXTtcbiAgICB0aGlzLl9rZXlGaWVsZCA9IGtleUZpZWxkO1xuICAgIHRoaXMuX3NvcnRPcmRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0RmllbGQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSBbXTtcbiAgICB0aGlzLl9maWx0ZXJzID0ge307XG4gICAgdGhpcy5fcGFnZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaXplUGVyUGFnZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGVkaXQocm93SWQsIGRhdGFGaWVsZCwgbmV3VmFsdWUpIHtcbiAgICBjb25zdCByb3cgPSBnZXRSb3dCeVJvd0lkKHRoaXMpKHJvd0lkKTtcbiAgICBpZiAocm93KSBfLnNldChyb3csIGRhdGFGaWVsZCwgbmV3VmFsdWUpO1xuICB9XG5cbiAgc2V0U29ydCh7IGRhdGFGaWVsZCB9LCBvcmRlciwgZGVmYXVsdE9yZGVyKSB7XG4gICAgdGhpcy5zb3J0T3JkZXIgPSBuZXh0T3JkZXIodGhpcykoZGF0YUZpZWxkLCBvcmRlciwgZGVmYXVsdE9yZGVyKTtcbiAgICB0aGlzLnNvcnRGaWVsZCA9IGRhdGFGaWVsZDtcbiAgfVxuXG4gIHNvcnRCeSh7IHNvcnRGdW5jIH0pIHtcbiAgICB0aGlzLmRhdGEgPSBzb3J0KHRoaXMpKHNvcnRGdW5jKTtcbiAgfVxuXG4gIGdldEFsbERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cblxuICBzZXRBbGxEYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9maWx0ZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX2ZpbHRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2ZpbHRlcmVkRGF0YSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAoZGF0YSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpIDogW10pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBmaWx0ZXJlZERhdGEoKSB7IHJldHVybiB0aGlzLl9maWx0ZXJlZERhdGE7IH1cbiAgc2V0IGZpbHRlcmVkRGF0YShmaWx0ZXJlZERhdGEpIHsgdGhpcy5fZmlsdGVyZWREYXRhID0gZmlsdGVyZWREYXRhOyB9XG5cbiAgZ2V0IGtleUZpZWxkKCkgeyByZXR1cm4gdGhpcy5fa2V5RmllbGQ7IH1cbiAgc2V0IGtleUZpZWxkKGtleUZpZWxkKSB7IHRoaXMuX2tleUZpZWxkID0ga2V5RmllbGQ7IH1cblxuICBnZXQgc29ydE9yZGVyKCkgeyByZXR1cm4gdGhpcy5fc29ydE9yZGVyOyB9XG4gIHNldCBzb3J0T3JkZXIoc29ydE9yZGVyKSB7IHRoaXMuX3NvcnRPcmRlciA9IHNvcnRPcmRlcjsgfVxuXG4gIGdldCBwYWdlKCkgeyByZXR1cm4gdGhpcy5fcGFnZTsgfVxuICBzZXQgcGFnZShwYWdlKSB7IHRoaXMuX3BhZ2UgPSBwYWdlOyB9XG5cbiAgZ2V0IHNpemVQZXJQYWdlKCkgeyByZXR1cm4gdGhpcy5fc2l6ZVBlclBhZ2U7IH1cbiAgc2V0IHNpemVQZXJQYWdlKHNpemVQZXJQYWdlKSB7IHRoaXMuX3NpemVQZXJQYWdlID0gc2l6ZVBlclBhZ2U7IH1cblxuICBnZXQgc29ydEZpZWxkKCkgeyByZXR1cm4gdGhpcy5fc29ydEZpZWxkOyB9XG4gIHNldCBzb3J0RmllbGQoc29ydEZpZWxkKSB7IHRoaXMuX3NvcnRGaWVsZCA9IHNvcnRGaWVsZDsgfVxuXG4gIGdldCBzZWxlY3RlZCgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9XG4gIHNldCBzZWxlY3RlZChzZWxlY3RlZCkgeyB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkOyB9XG5cbiAgZ2V0IGZpbHRlcnMoKSB7IHJldHVybiB0aGlzLl9maWx0ZXJzOyB9XG4gIHNldCBmaWx0ZXJzKGZpbHRlcnMpIHsgdGhpcy5fZmlsdGVycyA9IGZpbHRlcnM7IH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL2luZGV4LmpzIiwiLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXG4vKiBlc2xpbnQgbm8tbG9uZWx5LWlmOiAwICovXG4vKiBlc2xpbnQgbm8tdW5kZXJzY29yZS1kYW5nbGU6IDAgKi9cbmltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi9jb25zdCc7XG5cbmZ1bmN0aW9uIGNvbXBhcmF0b3IoYSwgYikge1xuICBsZXQgcmVzdWx0O1xuICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gYi5sb2NhbGVDb21wYXJlKGEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGEgPiBiID8gLTEgOiAoKGEgPCBiKSA/IDEgOiAwKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY29uc3Qgc29ydCA9ICh7IGRhdGEsIHNvcnRPcmRlciwgc29ydEZpZWxkIH0pID0+IChzb3J0RnVuYykgPT4ge1xuICBjb25zdCBfZGF0YSA9IFsuLi5kYXRhXTtcbiAgX2RhdGEuc29ydCgoYSwgYikgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IHZhbHVlQSA9IF8uZ2V0KGEsIHNvcnRGaWVsZCk7XG4gICAgbGV0IHZhbHVlQiA9IF8uZ2V0KGIsIHNvcnRGaWVsZCk7XG4gICAgdmFsdWVBID0gXy5pc0RlZmluZWQodmFsdWVBKSA/IHZhbHVlQSA6ICcnO1xuICAgIHZhbHVlQiA9IF8uaXNEZWZpbmVkKHZhbHVlQikgPyB2YWx1ZUIgOiAnJztcblxuICAgIGlmIChzb3J0RnVuYykge1xuICAgICAgcmVzdWx0ID0gc29ydEZ1bmModmFsdWVBLCB2YWx1ZUIsIHNvcnRPcmRlciwgc29ydEZpZWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvcnRPcmRlciA9PT0gQ29uc3QuU09SVF9ERVNDKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbXBhcmF0b3IodmFsdWVBLCB2YWx1ZUIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY29tcGFyYXRvcih2YWx1ZUIsIHZhbHVlQSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gX2RhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgbmV4dE9yZGVyID0gc3RvcmUgPT4gKGZpZWxkLCBvcmRlciwgZGVmYXVsdE9yZGVyID0gQ29uc3QuU09SVF9ERVNDKSA9PiB7XG4gIGlmIChvcmRlcikgcmV0dXJuIG9yZGVyO1xuXG4gIGlmIChmaWVsZCAhPT0gc3RvcmUuc29ydEZpZWxkKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRPcmRlcjtcbiAgfVxuICByZXR1cm4gc3RvcmUuc29ydE9yZGVyID09PSBDb25zdC5TT1JUX0RFU0MgPyBDb25zdC5TT1JUX0FTQyA6IENvbnN0LlNPUlRfREVTQztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9zb3J0LmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHJlbW90ZVJlc29sdmVyIGZyb20gJy4uL3Byb3BzLXJlc29sdmVyL3JlbW90ZS1yZXNvbHZlcic7XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2UgPT5cbiAgY2xhc3MgU29ydFdyYXBwZXIgZXh0ZW5kcyByZW1vdGVSZXNvbHZlcihDb21wb25lbnQpIHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgc3RvcmU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLmhhbmRsZVNvcnQgPSB0aGlzLmhhbmRsZVNvcnQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBjb25zdCB7IGNvbHVtbnMsIGRlZmF1bHRTb3J0ZWQsIGRlZmF1bHRTb3J0RGlyZWN0aW9uLCBzdG9yZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIC8vIGRlZmF1bHRTb3J0ZWQgaXMgYW4gYXJyYXksIGl0J3MgcmVhZHkgdG8gdXNlIGFzIG11bHRpIC8gc2luZ2xlIHNvcnRcbiAgICAgIC8vIHdoZW4gd2Ugc3RhcnQgdG8gc3VwcG9ydCBtdWx0aSBzb3J0LCBwbGVhc2UgdXBkYXRlIGZvbGxvd2luZyBjb2RlIHRvIHVzZSBhcnJheS5mb3JFYWNoXG4gICAgICBpZiAoZGVmYXVsdFNvcnRlZCAmJiBkZWZhdWx0U29ydGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YUZpZWxkID0gZGVmYXVsdFNvcnRlZFswXS5kYXRhRmllbGQ7XG4gICAgICAgIGNvbnN0IG9yZGVyID0gZGVmYXVsdFNvcnRlZFswXS5vcmRlcjtcbiAgICAgICAgY29uc3QgY29sdW1uID0gY29sdW1ucy5maWx0ZXIoY29sID0+IGNvbC5kYXRhRmllbGQgPT09IGRhdGFGaWVsZCk7XG4gICAgICAgIGlmIChjb2x1bW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0b3JlLnNldFNvcnQoY29sdW1uWzBdLCBvcmRlciwgZGVmYXVsdFNvcnREaXJlY3Rpb24pO1xuXG4gICAgICAgICAgaWYgKGNvbHVtblswXS5vblNvcnQpIHtcbiAgICAgICAgICAgIGNvbHVtblswXS5vblNvcnQoc3RvcmUuc29ydEZpZWxkLCBzdG9yZS5zb3J0T3JkZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmlzUmVtb3RlU29ydCgpIHx8IHRoaXMuaXNSZW1vdGVQYWdpbmF0aW9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU29ydENoYW5nZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9yZS5zb3J0QnkoY29sdW1uWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlU29ydCgpICYmICF0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpKSB7XG4gICAgICAgIGxldCBzb3J0ZWRDb2x1bW47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFByb3BzLmNvbHVtbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAobmV4dFByb3BzLmNvbHVtbnNbaV0uZGF0YUZpZWxkID09PSBuZXh0UHJvcHMuc3RvcmUuc29ydEZpZWxkKSB7XG4gICAgICAgICAgICBzb3J0ZWRDb2x1bW4gPSBuZXh0UHJvcHMuY29sdW1uc1tpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydGVkQ29sdW1uICYmIHNvcnRlZENvbHVtbi5zb3J0KSB7XG4gICAgICAgICAgbmV4dFByb3BzLnN0b3JlLnNvcnRCeShzb3J0ZWRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlU29ydChjb2x1bW4pIHtcbiAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICBzdG9yZS5zZXRTb3J0KGNvbHVtbiwgdW5kZWZpbmVkLCB0aGlzLnByb3BzLmRlZmF1bHRTb3J0RGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGNvbHVtbi5vblNvcnQpIHtcbiAgICAgICAgY29sdW1uLm9uU29ydChzdG9yZS5zb3J0RmllbGQsIHN0b3JlLnNvcnRPcmRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzUmVtb3RlU29ydCgpIHx8IHRoaXMuaXNSZW1vdGVQYWdpbmF0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTb3J0Q2hhbmdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5zb3J0QnkoY29sdW1uKTtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCYXNlXG4gICAgICAgICAgeyAuLi50aGlzLnByb3BzIH1cbiAgICAgICAgICBvblNvcnQ9eyB0aGlzLmhhbmRsZVNvcnQgfVxuICAgICAgICAgIGRhdGE9eyB0aGlzLnByb3BzLnN0b3JlLmRhdGEgfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L3dyYXBwZXIuanMiLCIvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuaW1wb3J0IHtcbiAgaXNBbnlTZWxlY3RlZFJvdyxcbiAgc2VsZWN0YWJsZUtleXMsXG4gIHVuU2VsZWN0YWJsZUtleXMsXG4gIGdldFNlbGVjdGVkUm93c1xufSBmcm9tICcuLi9zdG9yZS9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgZ2V0Um93QnlSb3dJZCB9IGZyb20gJy4uL3N0b3JlL3Jvd3MnO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlID0+XG4gIGNsYXNzIFJvd1NlbGVjdGlvbldyYXBwZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICBzdG9yZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgc2VsZWN0Um93OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5oYW5kbGVSb3dTZWxlY3QgPSB0aGlzLmhhbmRsZVJvd1NlbGVjdC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5oYW5kbGVBbGxSb3dzU2VsZWN0ID0gdGhpcy5oYW5kbGVBbGxSb3dzU2VsZWN0LmJpbmQodGhpcyk7XG5cbiAgICAgIHByb3BzLnN0b3JlLnNlbGVjdGVkID0gcHJvcHMuc2VsZWN0Um93LnNlbGVjdGVkIHx8IFtdO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBwcm9wcy5zdG9yZS5zZWxlY3RlZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgbmV4dFByb3BzLnN0b3JlLnNlbGVjdGVkID0gbmV4dFByb3BzLnNlbGVjdFJvdy5zZWxlY3RlZCB8fCBbXTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBuZXh0UHJvcHMuc3RvcmUuc2VsZWN0ZWRcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByb3cgc2VsZWN0aW9uIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm93S2V5IC0gcm93IGtleSBvZiB3aGF0IHdhcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrZWQgLSBuZXh0IGNoZWNrZWQgc3RhdHVzIG9mIGlucHV0IGJ1dHRvbi5cbiAgICAgKi9cbiAgICBoYW5kbGVSb3dTZWxlY3Qocm93S2V5LCBjaGVja2VkLCByb3dJbmRleCwgZSkge1xuICAgICAgY29uc3QgeyBzZWxlY3RSb3c6IHsgbW9kZSwgb25TZWxlY3QgfSwgc3RvcmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IFJPV19TRUxFQ1RfU0lOR0xFIH0gPSBDb25zdDtcblxuICAgICAgbGV0IGN1cnJTZWxlY3RlZCA9IFsuLi5zdG9yZS5zZWxlY3RlZF07XG5cbiAgICAgIGlmIChtb2RlID09PSBST1dfU0VMRUNUX1NJTkdMRSkgeyAvLyB3aGVuIHNlbGVjdCBtb2RlIGlzIHJhZGlvXG4gICAgICAgIGN1cnJTZWxlY3RlZCA9IFtyb3dLZXldO1xuICAgICAgfSBlbHNlIGlmIChjaGVja2VkKSB7IC8vIHdoZW4gc2VsZWN0IG1vZGUgaXMgY2hlY2tib3hcbiAgICAgICAgY3VyclNlbGVjdGVkLnB1c2gocm93S2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJTZWxlY3RlZCA9IGN1cnJTZWxlY3RlZC5maWx0ZXIodmFsdWUgPT4gdmFsdWUgIT09IHJvd0tleSk7XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLnNlbGVjdGVkID0gY3VyclNlbGVjdGVkO1xuXG4gICAgICBpZiAob25TZWxlY3QpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gZ2V0Um93QnlSb3dJZChzdG9yZSkocm93S2V5KTtcbiAgICAgICAgb25TZWxlY3Qocm93LCBjaGVja2VkLCByb3dJbmRleCwgZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgc2VsZWN0ZWRSb3dLZXlzOiBjdXJyU2VsZWN0ZWRcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgYWxsIHJvd3Mgc2VsZWN0aW9uIG9uIGhlYWRlciBjZWxsIGJ5IHN0b3JlLnNlbGVjdGVkXG4gICAgICovXG4gICAgaGFuZGxlQWxsUm93c1NlbGVjdChlKSB7XG4gICAgICBjb25zdCB7IHN0b3JlLCBzZWxlY3RSb3c6IHtcbiAgICAgICAgb25TZWxlY3RBbGwsXG4gICAgICAgIG5vblNlbGVjdGFibGVcbiAgICAgIH0gfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IGlzQW55U2VsZWN0ZWRSb3coc3RvcmUpKG5vblNlbGVjdGFibGUpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSAhc2VsZWN0ZWQ7XG5cbiAgICAgIGNvbnN0IGN1cnJTZWxlY3RlZCA9IHJlc3VsdCA/XG4gICAgICAgIHNlbGVjdGFibGVLZXlzKHN0b3JlKShub25TZWxlY3RhYmxlKSA6XG4gICAgICAgIHVuU2VsZWN0YWJsZUtleXMoc3RvcmUpKG5vblNlbGVjdGFibGUpO1xuXG5cbiAgICAgIHN0b3JlLnNlbGVjdGVkID0gY3VyclNlbGVjdGVkO1xuXG4gICAgICBpZiAob25TZWxlY3RBbGwpIHtcbiAgICAgICAgb25TZWxlY3RBbGwocmVzdWx0LCBnZXRTZWxlY3RlZFJvd3Moc3RvcmUpLCBlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICBzZWxlY3RlZFJvd0tleXM6IGN1cnJTZWxlY3RlZFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCYXNlXG4gICAgICAgICAgeyAuLi50aGlzLnByb3BzIH1cbiAgICAgICAgICBvblJvd1NlbGVjdD17IHRoaXMuaGFuZGxlUm93U2VsZWN0IH1cbiAgICAgICAgICBvbkFsbFJvd3NTZWxlY3Q9eyB0aGlzLmhhbmRsZUFsbFJvd3NTZWxlY3QgfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VsZWN0aW9uL3dyYXBwZXIuanMiXSwic291cmNlUm9vdCI6IiJ9
//# sourceMappingURL=react-bootstrap-table-next.js.map