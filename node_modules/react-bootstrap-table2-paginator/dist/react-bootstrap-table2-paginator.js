(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactBootstrapTable2Paginator"] = factory(require("react"));
	else
		root["ReactBootstrapTable2Paginator"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(6)();
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  PAGINATION_SIZE: 5,
  PAGE_START_INDEX: 1,
  With_FIRST_AND_LAST: true,
  SHOW_ALL_PAGE_BTNS: false,
  SHOW_TOTAL: false,
  PAGINATION_TOTAL: null,
  FIRST_PAGE_TEXT: '<<',
  PRE_PAGE_TEXT: '<',
  NEXT_PAGE_TEXT: '>',
  LAST_PAGE_TEXT: '>>',
  NEXT_PAGE_TITLE: 'next page',
  LAST_PAGE_TITLE: 'last page',
  PRE_PAGE_TITLE: 'previous page',
  FIRST_PAGE_TITLE: 'first page',
  SIZE_PER_PAGE_LIST: [10, 25, 30, 50],
  HIDE_SIZE_PER_PAGE: false,
  HIDE_PAGE_LIST_ONLY_ONE_PAGE: false
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _wrapper = __webpack_require__(5);

var _wrapper2 = _interopRequireDefault(_wrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    wrapperFactory: _wrapper2.default,
    options: options
  };
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _pagination = __webpack_require__(10);

var _pagination2 = _interopRequireDefault(_pagination);

var _page = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


exports.default = function (Base, _ref) {
  var _class, _temp;

  var remoteResolver = _ref.remoteResolver;
  return _temp = _class = function (_remoteResolver) {
    _inherits(PaginationWrapper, _remoteResolver);

    function PaginationWrapper(props) {
      _classCallCheck(this, PaginationWrapper);

      var _this = _possibleConstructorReturn(this, (PaginationWrapper.__proto__ || Object.getPrototypeOf(PaginationWrapper)).call(this, props));

      _this.handleChangePage = _this.handleChangePage.bind(_this);
      _this.handleChangeSizePerPage = _this.handleChangeSizePerPage.bind(_this);

      var currPage = void 0;
      var currSizePerPage = void 0;
      var options = props.pagination.options;

      var sizePerPageList = options.sizePerPageList || _const2.default.SIZE_PER_PAGE_LIST;

      // initialize current page
      if (typeof options.page !== 'undefined') {
        currPage = options.page;
      } else if (typeof options.pageStartIndex !== 'undefined') {
        currPage = options.pageStartIndex;
      } else {
        currPage = _const2.default.PAGE_START_INDEX;
      }

      // initialize current sizePerPage
      if (typeof options.sizePerPage !== 'undefined') {
        currSizePerPage = options.sizePerPage;
      } else if (_typeof(sizePerPageList[0]) === 'object') {
        currSizePerPage = sizePerPageList[0].value;
      } else {
        currSizePerPage = sizePerPageList[0];
      }

      _this.state = { currPage: currPage, currSizePerPage: currSizePerPage };
      _this.saveToStore(currPage, currSizePerPage);
      return _this;
    }

    _createClass(PaginationWrapper, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var needNewState = false;
        var _state = this.state,
            currPage = _state.currPage,
            currSizePerPage = _state.currSizePerPage;
        var _nextProps$pagination = nextProps.pagination.options,
            page = _nextProps$pagination.page,
            sizePerPage = _nextProps$pagination.sizePerPage,
            pageStartIndex = _nextProps$pagination.pageStartIndex,
            onPageChange = _nextProps$pagination.onPageChange;


        if (typeof page !== 'undefined' && currPage !== page) {
          // user defined page
          currPage = page;
          needNewState = true;
        } else if (nextProps.isDataChanged) {
          needNewState = true;
        }

        if (typeof currPage === 'undefined') {
          currPage = typeof pageStartIndex !== 'undefined' ? pageStartIndex : _const2.default.PAGE_START_INDEX;
        }

        if (typeof sizePerPage !== 'undefined') {
          currSizePerPage = sizePerPage;
          needNewState = true;
        }

        this.saveToStore(currPage, currSizePerPage);

        if (needNewState) {
          if (onPageChange) {
            onPageChange(currPage, currSizePerPage);
          }
          this.setState(function () {
            return { currPage: currPage, currSizePerPage: currSizePerPage };
          });
        }
      }
    }, {
      key: 'saveToStore',
      value: function saveToStore(page, sizePerPage) {
        this.props.store.page = page;
        this.props.store.sizePerPage = sizePerPage;
      }
    }, {
      key: 'handleChangePage',
      value: function handleChangePage(currPage) {
        var currSizePerPage = this.state.currSizePerPage;
        var options = this.props.pagination.options;

        this.saveToStore(currPage, currSizePerPage);

        if (options.onPageChange) {
          options.onPageChange(currPage, currSizePerPage);
        }
        if (this.isRemotePagination()) {
          this.handleRemotePageChange();
          return;
        }
        this.setState(function () {
          return { currPage: currPage };
        });
      }
    }, {
      key: 'handleChangeSizePerPage',
      value: function handleChangeSizePerPage(currSizePerPage, currPage) {
        var options = this.props.pagination.options;

        this.saveToStore(currPage, currSizePerPage);

        if (options.onSizePerPageChange) {
          options.onSizePerPageChange(currSizePerPage, currPage);
        }
        if (this.isRemotePagination()) {
          this.handleRemotePageChange();
          return;
        }
        this.setState(function () {
          return {
            currPage: currPage,
            currSizePerPage: currSizePerPage
          };
        });
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            options = _props.pagination.options,
            store = _props.store;
        var _state2 = this.state,
            currPage = _state2.currPage,
            currSizePerPage = _state2.currSizePerPage;

        var withFirstAndLast = typeof options.withFirstAndLast === 'undefined' ? _const2.default.With_FIRST_AND_LAST : options.withFirstAndLast;
        var alwaysShowAllBtns = typeof options.alwaysShowAllBtns === 'undefined' ? _const2.default.SHOW_ALL_PAGE_BTNS : options.alwaysShowAllBtns;
        var hideSizePerPage = typeof options.hideSizePerPage === 'undefined' ? _const2.default.HIDE_SIZE_PER_PAGE : options.hideSizePerPage;
        var hidePageListOnlyOnePage = typeof options.hidePageListOnlyOnePage === 'undefined' ? _const2.default.HIDE_PAGE_LIST_ONLY_ONE_PAGE : options.hidePageListOnlyOnePage;
        var pageStartIndex = typeof options.pageStartIndex === 'undefined' ? _const2.default.PAGE_START_INDEX : options.pageStartIndex;

        var data = this.isRemotePagination() ? this.props.data : (0, _page.getByCurrPage)(store, pageStartIndex);

        return [_react2.default.createElement(Base, _extends({ key: 'table' }, this.props, { data: data })), _react2.default.createElement(_pagination2.default, {
          key: 'pagination',
          dataSize: options.totalSize || store.data.length,
          currPage: currPage,
          currSizePerPage: currSizePerPage,
          onPageChange: this.handleChangePage,
          onSizePerPageChange: this.handleChangeSizePerPage,
          sizePerPageList: options.sizePerPageList || _const2.default.SIZE_PER_PAGE_LIST,
          paginationSize: options.paginationSize || _const2.default.PAGINATION_SIZE,
          pageStartIndex: pageStartIndex,
          withFirstAndLast: withFirstAndLast,
          alwaysShowAllBtns: alwaysShowAllBtns,
          hideSizePerPage: hideSizePerPage,
          hidePageListOnlyOnePage: hidePageListOnlyOnePage,
          showTotal: options.showTotal,
          paginationTotalRenderer: options.paginationTotalRenderer,
          firstPageText: options.firstPageText || _const2.default.FIRST_PAGE_TEXT,
          prePageText: options.prePageText || _const2.default.PRE_PAGE_TEXT,
          nextPageText: options.nextPageText || _const2.default.NEXT_PAGE_TEXT,
          lastPageText: options.lastPageText || _const2.default.LAST_PAGE_TEXT,
          prePageTitle: options.prePageTitle || _const2.default.PRE_PAGE_TITLE,
          nextPageTitle: options.nextPageTitle || _const2.default.NEXT_PAGE_TITLE,
          firstPageTitle: options.firstPageTitle || _const2.default.FIRST_PAGE_TITLE,
          lastPageTitle: options.lastPageTitle || _const2.default.LAST_PAGE_TITLE
        })];
      }
    }]);

    return PaginationWrapper;
  }(remoteResolver(_react.Component)), _class.propTypes = {
    store: _propTypes2.default.object.isRequired
  }, _temp;
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(7);
var invariant = __webpack_require__(8);
var ReactPropTypesSecret = __webpack_require__(9);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _pageResolver2 = __webpack_require__(11);

var _pageResolver3 = _interopRequireDefault(_pageResolver2);

var _sizePerPageDropdown = __webpack_require__(12);

var _sizePerPageDropdown2 = _interopRequireDefault(_sizePerPageDropdown);

var _paginationList = __webpack_require__(14);

var _paginationList2 = _interopRequireDefault(_paginationList);

var _paginationTotal = __webpack_require__(16);

var _paginationTotal2 = _interopRequireDefault(_paginationTotal);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint arrow-body-style: 0 */


var Pagination = function (_pageResolver) {
  _inherits(Pagination, _pageResolver);

  function Pagination(props) {
    _classCallCheck(this, Pagination);

    var _this = _possibleConstructorReturn(this, (Pagination.__proto__ || Object.getPrototypeOf(Pagination)).call(this, props));

    _this.defaultTotal = function (from, to, size) {
      return _react2.default.createElement(_paginationTotal2.default, {
        from: from,
        to: to,
        dataSize: size
      });
    };

    _this.setTotal = function (from, to, size, total) {
      if (total && typeof total === 'function') {
        return total(from, to, size);
      }

      return _this.defaultTotal(from, to, size);
    };

    _this.closeDropDown = _this.closeDropDown.bind(_this);
    _this.toggleDropDown = _this.toggleDropDown.bind(_this);
    _this.handleChangePage = _this.handleChangePage.bind(_this);
    _this.handleChangeSizePerPage = _this.handleChangeSizePerPage.bind(_this);
    _this.state = _this.initialState();
    return _this;
  }

  _createClass(Pagination, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var dataSize = nextProps.dataSize,
          currSizePerPage = nextProps.currSizePerPage;

      if (currSizePerPage !== this.props.currSizePerPage || dataSize !== this.props.dataSize) {
        var totalPages = this.calculateTotalPage(currSizePerPage, dataSize);
        var lastPage = this.calculateLastPage(totalPages);
        this.setState({ totalPages: totalPages, lastPage: lastPage });
      }
    }
  }, {
    key: 'toggleDropDown',
    value: function toggleDropDown() {
      var dropdownOpen = !this.state.dropdownOpen;
      this.setState(function () {
        return { dropdownOpen: dropdownOpen };
      });
    }
  }, {
    key: 'closeDropDown',
    value: function closeDropDown() {
      this.setState(function () {
        return { dropdownOpen: false };
      });
    }
  }, {
    key: 'handleChangeSizePerPage',
    value: function handleChangeSizePerPage(sizePerPage) {
      var _props = this.props,
          currSizePerPage = _props.currSizePerPage,
          onSizePerPageChange = _props.onSizePerPageChange;

      var selectedSize = typeof sizePerPage === 'string' ? parseInt(sizePerPage, 10) : sizePerPage;
      var currPage = this.props.currPage;

      if (selectedSize !== currSizePerPage) {
        var newTotalPages = this.calculateTotalPage(selectedSize);
        var newLastPage = this.calculateLastPage(newTotalPages);
        if (currPage > newLastPage) currPage = newLastPage;
        onSizePerPageChange(selectedSize, currPage);
      }
      this.closeDropDown();
    }
  }, {
    key: 'handleChangePage',
    value: function handleChangePage(newPage) {
      var page = void 0;
      var _props2 = this.props,
          currPage = _props2.currPage,
          pageStartIndex = _props2.pageStartIndex,
          prePageText = _props2.prePageText,
          nextPageText = _props2.nextPageText,
          lastPageText = _props2.lastPageText,
          firstPageText = _props2.firstPageText,
          onPageChange = _props2.onPageChange;
      var lastPage = this.state.lastPage;


      if (newPage === prePageText) {
        page = this.backToPrevPage();
      } else if (newPage === nextPageText) {
        page = currPage + 1 > lastPage ? lastPage : currPage + 1;
      } else if (newPage === lastPageText) {
        page = lastPage;
      } else if (newPage === firstPageText) {
        page = pageStartIndex;
      } else {
        page = parseInt(newPage, 10);
      }

      // if (keepSizePerPageState) { this.closeDropDown(); }

      if (page !== currPage) {
        onPageChange(page);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          totalPages = _state.totalPages,
          lastPage = _state.lastPage,
          open = _state.dropdownOpen;
      var _props3 = this.props,
          showTotal = _props3.showTotal,
          dataSize = _props3.dataSize,
          paginationTotalRenderer = _props3.paginationTotalRenderer,
          sizePerPageList = _props3.sizePerPageList,
          currSizePerPage = _props3.currSizePerPage,
          hideSizePerPage = _props3.hideSizePerPage,
          hidePageListOnlyOnePage = _props3.hidePageListOnlyOnePage;

      var pages = this.calculatePageStatus(this.calculatePages(totalPages), lastPage);

      var _calculateFromTo = this.calculateFromTo(),
          _calculateFromTo2 = _slicedToArray(_calculateFromTo, 2),
          from = _calculateFromTo2[0],
          to = _calculateFromTo2[1];

      var pageListClass = (0, _classnames2.default)('react-bootstrap-table-pagination-list', 'col-md-6 col-xs-6 col-sm-6 col-lg-6', {
        'react-bootstrap-table-pagination-list-hidden': hidePageListOnlyOnePage && totalPages === 1
      });
      return _react2.default.createElement(
        'div',
        { className: 'row react-bootstrap-table-pagination' },
        _react2.default.createElement(
          'div',
          { className: 'col-md-6 col-xs-6 col-sm-6 col-lg-6' },
          sizePerPageList.length > 1 && !hideSizePerPage ? _react2.default.createElement(_sizePerPageDropdown2.default, {
            currSizePerPage: '' + currSizePerPage,
            options: this.calculateSizePerPageStatus(),
            onSizePerPageChange: this.handleChangeSizePerPage,
            onClick: this.toggleDropDown,
            onBlur: this.closeDropDown,
            open: open
          }) : null,
          showTotal ? this.setTotal(from, to, dataSize, paginationTotalRenderer) : null
        ),
        _react2.default.createElement(
          'div',
          { className: pageListClass },
          _react2.default.createElement(_paginationList2.default, { pages: pages, onPageChange: this.handleChangePage })
        )
      );
    }
  }]);

  return Pagination;
}((0, _pageResolver3.default)(_react.Component));

Pagination.propTypes = {
  dataSize: _propTypes2.default.number.isRequired,
  sizePerPageList: _propTypes2.default.array.isRequired,
  currPage: _propTypes2.default.number.isRequired,
  currSizePerPage: _propTypes2.default.number.isRequired,
  onPageChange: _propTypes2.default.func.isRequired,
  onSizePerPageChange: _propTypes2.default.func.isRequired,
  pageStartIndex: _propTypes2.default.number,
  paginationSize: _propTypes2.default.number,
  showTotal: _propTypes2.default.bool,
  paginationTotalRenderer: _propTypes2.default.func,
  firstPageText: _propTypes2.default.string,
  prePageText: _propTypes2.default.string,
  nextPageText: _propTypes2.default.string,
  lastPageText: _propTypes2.default.string,
  nextPageTitle: _propTypes2.default.string,
  prePageTitle: _propTypes2.default.string,
  firstPageTitle: _propTypes2.default.string,
  lastPageTitle: _propTypes2.default.string,
  withFirstAndLast: _propTypes2.default.bool,
  alwaysShowAllBtns: _propTypes2.default.bool,
  hideSizePerPage: _propTypes2.default.bool,
  hidePageListOnlyOnePage: _propTypes2.default.bool
};

Pagination.defaultProps = {
  pageStartIndex: _const2.default.PAGE_START_INDEX,
  paginationSize: _const2.default.PAGINATION_SIZE,
  withFirstAndLast: _const2.default.With_FIRST_AND_LAST,
  alwaysShowAllBtns: _const2.default.SHOW_ALL_PAGE_BTNS,
  showTotal: _const2.default.SHOW_TOTAL,
  paginationTotalRenderer: _const2.default.PAGINATION_TOTAL,
  firstPageText: _const2.default.FIRST_PAGE_TEXT,
  prePageText: _const2.default.PRE_PAGE_TEXT,
  nextPageText: _const2.default.NEXT_PAGE_TEXT,
  lastPageText: _const2.default.LAST_PAGE_TEXT,
  sizePerPageList: _const2.default.SIZE_PER_PAGE_LIST,
  nextPageTitle: _const2.default.NEXT_PAGE_TITLE,
  prePageTitle: _const2.default.PRE_PAGE_TITLE,
  firstPageTitle: _const2.default.FIRST_PAGE_TITLE,
  lastPageTitle: _const2.default.LAST_PAGE_TITLE,
  hideSizePerPage: _const2.default.HIDE_SIZE_PER_PAGE,
  hidePageListOnlyOnePage: _const2.default.HIDE_PAGE_LIST_ONLY_ONE_PAGE
};

exports.default = Pagination;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-mixed-operators: 0 */


exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(PageResolver, _ExtendBase);

    function PageResolver() {
      _classCallCheck(this, PageResolver);

      return _possibleConstructorReturn(this, (PageResolver.__proto__ || Object.getPrototypeOf(PageResolver)).apply(this, arguments));
    }

    _createClass(PageResolver, [{
      key: 'backToPrevPage',
      value: function backToPrevPage() {
        var _props = this.props,
            currPage = _props.currPage,
            pageStartIndex = _props.pageStartIndex;

        return currPage - 1 < pageStartIndex ? pageStartIndex : currPage - 1;
      }
    }, {
      key: 'goToNextPage',
      value: function goToNextPage() {
        var currPage = this.props.currPage;
        var lastPage = this.state.lastPage;

        return currPage + 1 > lastPage ? lastPage : currPage + 1;
      }
    }, {
      key: 'initialState',
      value: function initialState() {
        var totalPages = this.calculateTotalPage();
        var lastPage = this.calculateLastPage(totalPages);
        return { totalPages: totalPages, lastPage: lastPage, dropdownOpen: false };
      }
    }, {
      key: 'calculateTotalPage',
      value: function calculateTotalPage() {
        var sizePerPage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.currSizePerPage;
        var dataSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.dataSize;

        return Math.ceil(dataSize / sizePerPage);
      }
    }, {
      key: 'calculateLastPage',
      value: function calculateLastPage(totalPages) {
        var pageStartIndex = this.props.pageStartIndex;

        return pageStartIndex + totalPages - 1;
      }
    }, {
      key: 'calculateFromTo',
      value: function calculateFromTo() {
        var _props2 = this.props,
            dataSize = _props2.dataSize,
            currPage = _props2.currPage,
            currSizePerPage = _props2.currSizePerPage,
            pageStartIndex = _props2.pageStartIndex;

        var offset = Math.abs(_const2.default.PAGE_START_INDEX - pageStartIndex);

        var from = (currPage - pageStartIndex) * currSizePerPage;
        from = dataSize === 0 ? 0 : from + 1;
        var to = Math.min(currSizePerPage * (currPage + offset) - 1, dataSize);
        if (to >= dataSize) to -= 1;

        return [from, to];
      }
    }, {
      key: 'calculatePages',
      value: function calculatePages() {
        var totalPages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.totalPages;
        var lastPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastPage;
        var _props3 = this.props,
            currPage = _props3.currPage,
            paginationSize = _props3.paginationSize,
            pageStartIndex = _props3.pageStartIndex,
            withFirstAndLast = _props3.withFirstAndLast,
            firstPageText = _props3.firstPageText,
            prePageText = _props3.prePageText,
            nextPageText = _props3.nextPageText,
            lastPageText = _props3.lastPageText,
            alwaysShowAllBtns = _props3.alwaysShowAllBtns;


        var pages = void 0;
        var endPage = totalPages;
        if (endPage <= 0) return [];

        var startPage = Math.max(currPage - Math.floor(paginationSize / 2), pageStartIndex);
        endPage = startPage + paginationSize - 1;

        if (endPage > lastPage) {
          endPage = lastPage;
          startPage = endPage - paginationSize + 1;
        }

        if (startPage !== pageStartIndex && totalPages > paginationSize && withFirstAndLast) {
          pages = [firstPageText, prePageText];
        } else if (totalPages > 1 || alwaysShowAllBtns) {
          pages = [prePageText];
        } else {
          pages = [];
        }

        for (var i = startPage; i <= endPage; i += 1) {
          if (i >= pageStartIndex) pages.push(i);
        }

        if (endPage <= lastPage && pages.length > 1) {
          pages.push(nextPageText);
        }
        if (endPage !== lastPage && withFirstAndLast) {
          pages.push(lastPageText);
        }
        return pages;
      }
    }, {
      key: 'calculatePageStatus',
      value: function calculatePageStatus() {
        var _this2 = this;

        var pages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var lastPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastPage;
        var _props4 = this.props,
            currPage = _props4.currPage,
            pageStartIndex = _props4.pageStartIndex,
            firstPageText = _props4.firstPageText,
            prePageText = _props4.prePageText,
            nextPageText = _props4.nextPageText,
            lastPageText = _props4.lastPageText,
            alwaysShowAllBtns = _props4.alwaysShowAllBtns;

        var isStart = function isStart(page) {
          return currPage === pageStartIndex && (page === firstPageText || page === prePageText);
        };
        var isEnd = function isEnd(page) {
          return currPage === lastPage && (page === nextPageText || page === lastPageText);
        };

        return pages.filter(function (page) {
          if (alwaysShowAllBtns) {
            return true;
          }
          return !(isStart(page) || isEnd(page));
        }).map(function (page) {
          var title = void 0;
          var active = page === currPage;
          var disabled = isStart(page) || isEnd(page);

          if (page === nextPageText) {
            title = _this2.props.nextPageTitle;
          } else if (page === prePageText) {
            title = _this2.props.prePageTitle;
          } else if (page === firstPageText) {
            title = _this2.props.firstPageTitle;
          } else if (page === lastPageText) {
            title = _this2.props.lastPageTitle;
          } else {
            title = '' + page;
          }

          return { page: page, active: active, disabled: disabled, title: title };
        });
      }
    }, {
      key: 'calculateSizePerPageStatus',
      value: function calculateSizePerPageStatus() {
        var sizePerPageList = this.props.sizePerPageList;

        return sizePerPageList.map(function (_sizePerPage) {
          var pageText = _sizePerPage.text || _sizePerPage;
          var pageNumber = _sizePerPage.value || _sizePerPage;
          return {
            text: '' + pageText,
            page: pageNumber
          };
        });
      }
    }]);

    return PageResolver;
  }(ExtendBase);
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _sizePerPageOption = __webpack_require__(13);

var _sizePerPageOption2 = _interopRequireDefault(_sizePerPageOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sizePerPageDefaultClass = 'react-bs-table-sizePerPage-dropdown';

var SizePerPageDropDown = function SizePerPageDropDown(props) {
  var open = props.open,
      hidden = props.hidden,
      onClick = props.onClick,
      onBlur = props.onBlur,
      options = props.options,
      className = props.className,
      variation = props.variation,
      btnContextual = props.btnContextual,
      currSizePerPage = props.currSizePerPage,
      onSizePerPageChange = props.onSizePerPageChange;


  var dropDownStyle = { visibility: hidden ? 'hidden' : 'visible' };
  var dropdownClasses = (0, _classnames2.default)(open ? 'open show' : '', sizePerPageDefaultClass, variation, className);

  return _react2.default.createElement(
    'span',
    {
      style: dropDownStyle,
      className: dropdownClasses
    },
    _react2.default.createElement(
      'button',
      {
        id: 'pageDropDown',
        className: 'btn ' + btnContextual + ' dropdown-toggle',
        'data-toggle': 'dropdown',
        'aria-expanded': open,
        onClick: onClick,
        onBlur: onBlur
      },
      currSizePerPage,
      _react2.default.createElement(
        'span',
        null,
        ' ',
        _react2.default.createElement('span', { className: 'caret' })
      )
    ),
    _react2.default.createElement(
      'ul',
      { className: 'dropdown-menu', role: 'menu', 'aria-labelledby': 'pageDropDown' },
      options.map(function (option) {
        return _react2.default.createElement(_sizePerPageOption2.default, _extends({}, option, {
          key: option.text,
          onSizePerPageChange: onSizePerPageChange
        }));
      })
    )
  );
};

SizePerPageDropDown.propTypes = {
  currSizePerPage: _propTypes2.default.string.isRequired,
  options: _propTypes2.default.array.isRequired,
  onClick: _propTypes2.default.func.isRequired,
  onBlur: _propTypes2.default.func.isRequired,
  onSizePerPageChange: _propTypes2.default.func.isRequired,
  open: _propTypes2.default.bool,
  hidden: _propTypes2.default.bool,
  btnContextual: _propTypes2.default.string,
  variation: _propTypes2.default.oneOf(['dropdown', 'dropup']),
  className: _propTypes2.default.string
};
SizePerPageDropDown.defaultProps = {
  open: false,
  hidden: false,
  btnContextual: 'btn-default btn-secondary',
  variation: 'dropdown',
  className: ''
};

exports.default = SizePerPageDropDown;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint jsx-a11y/href-no-hash: 0 */
var SizePerPageOption = function SizePerPageOption(_ref) {
  var text = _ref.text,
      page = _ref.page,
      onSizePerPageChange = _ref.onSizePerPageChange;
  return _react2.default.createElement(
    'li',
    { key: text, role: 'presentation', className: 'dropdown-item' },
    _react2.default.createElement(
      'a',
      {
        href: '#',
        tabIndex: '-1',
        role: 'menuitem',
        'data-page': page,
        onMouseDown: function onMouseDown(e) {
          e.preventDefault();
          onSizePerPageChange(page);
        }
      },
      text
    )
  );
};

SizePerPageOption.propTypes = {
  text: _propTypes2.default.string.isRequired,
  page: _propTypes2.default.number.isRequired,
  onSizePerPageChange: _propTypes2.default.func.isRequired
};

exports.default = SizePerPageOption;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _pageButton = __webpack_require__(15);

var _pageButton2 = _interopRequireDefault(_pageButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PaginatonList = function PaginatonList(props) {
  return _react2.default.createElement(
    'ul',
    { className: 'pagination react-bootstrap-table-page-btns-ul' },
    props.pages.map(function (pageProps) {
      return _react2.default.createElement(_pageButton2.default, _extends({
        key: pageProps.page
      }, pageProps, {
        onPageChange: props.onPageChange
      }));
    })
  );
};

PaginatonList.propTypes = {
  pages: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    page: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    active: _propTypes2.default.bool,
    disable: _propTypes2.default.bool,
    title: _propTypes2.default.string
  })).isRequired,
  onPageChange: _propTypes2.default.func.isRequired
};

exports.default = PaginatonList;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = __webpack_require__(3);

var _classnames2 = _interopRequireDefault(_classnames);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint jsx-a11y/href-no-hash: 0 */


var PageButton = function (_Component) {
  _inherits(PageButton, _Component);

  function PageButton(props) {
    _classCallCheck(this, PageButton);

    var _this = _possibleConstructorReturn(this, (PageButton.__proto__ || Object.getPrototypeOf(PageButton)).call(this, props));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(PageButton, [{
    key: 'handleClick',
    value: function handleClick(e) {
      e.preventDefault();
      this.props.onPageChange(this.props.page);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          page = _props.page,
          title = _props.title,
          active = _props.active,
          disabled = _props.disabled;

      var classes = (0, _classnames2.default)({
        active: active,
        disabled: disabled,
        'page-item': true
      });

      return _react2.default.createElement(
        'li',
        { className: classes, title: title },
        _react2.default.createElement(
          'a',
          { href: '#', onClick: this.handleClick, className: 'page-link' },
          page
        )
      );
    }
  }]);

  return PageButton;
}(_react.Component);

PageButton.propTypes = {
  onPageChange: _propTypes2.default.func.isRequired,
  page: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]).isRequired,
  active: _propTypes2.default.bool.isRequired,
  disabled: _propTypes2.default.bool.isRequired,
  title: _propTypes2.default.string
};

exports.default = PageButton;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PaginationTotal = function PaginationTotal(props) {
  return _react2.default.createElement(
    'span',
    { className: 'react-bootstrap-table-pagination-total' },
    '\xA0Showing rows ',
    props.from,
    ' to\xA0',
    props.to + 1,
    ' of\xA0',
    props.dataSize
  );
};

PaginationTotal.propTypes = {
  from: _propTypes2.default.number.isRequired,
  to: _propTypes2.default.number.isRequired,
  dataSize: _propTypes2.default.number.isRequired
};

exports.default = PaginationTotal;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var getByCurrPage = exports.getByCurrPage = function getByCurrPage(store, pageStartIndex) {
  var dataSize = store.data.length;
  if (!dataSize) return [];
  var getNormalizedPage = function getNormalizedPage() {
    var offset = Math.abs(1 - pageStartIndex);
    return store.page + offset;
  };
  var end = getNormalizedPage() * store.sizePerPage - 1;
  var start = end - (store.sizePerPage - 1);

  var result = [];
  for (var i = start; i <= end; i += 1) {
    result.push(store.data[i]);
    if (i + 1 === dataSize) break;
  }
  return result;
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA2MTIyMTBkYjBlZjNkZTdlYjQ5MyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLXBhZ2luYXRvci9zcmMvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1wYWdpbmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1wYWdpbmF0b3Ivc3JjL3dyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9wYWdpbmF0aW9uLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9wYWdlLXJlc29sdmVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9zaXplLXBlci1wYWdlLWRyb3Bkb3duLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9zaXplLXBlci1wYWdlLW9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLXBhZ2luYXRvci9zcmMvcGFnaW5hdGlvbi1saXN0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9wYWdlLWJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLXBhZ2luYXRvci9zcmMvcGFnaW5hdGlvbi10b3RhbC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLXBhZ2luYXRvci9zcmMvcGFnZS5qcyJdLCJuYW1lcyI6WyJQQUdJTkFUSU9OX1NJWkUiLCJQQUdFX1NUQVJUX0lOREVYIiwiV2l0aF9GSVJTVF9BTkRfTEFTVCIsIlNIT1dfQUxMX1BBR0VfQlROUyIsIlNIT1dfVE9UQUwiLCJQQUdJTkFUSU9OX1RPVEFMIiwiRklSU1RfUEFHRV9URVhUIiwiUFJFX1BBR0VfVEVYVCIsIk5FWFRfUEFHRV9URVhUIiwiTEFTVF9QQUdFX1RFWFQiLCJORVhUX1BBR0VfVElUTEUiLCJMQVNUX1BBR0VfVElUTEUiLCJQUkVfUEFHRV9USVRMRSIsIkZJUlNUX1BBR0VfVElUTEUiLCJTSVpFX1BFUl9QQUdFX0xJU1QiLCJISURFX1NJWkVfUEVSX1BBR0UiLCJISURFX1BBR0VfTElTVF9PTkxZX09ORV9QQUdFIiwib3B0aW9ucyIsIndyYXBwZXJGYWN0b3J5IiwiQmFzZSIsInJlbW90ZVJlc29sdmVyIiwicHJvcHMiLCJoYW5kbGVDaGFuZ2VQYWdlIiwiYmluZCIsImhhbmRsZUNoYW5nZVNpemVQZXJQYWdlIiwiY3VyclBhZ2UiLCJjdXJyU2l6ZVBlclBhZ2UiLCJwYWdpbmF0aW9uIiwic2l6ZVBlclBhZ2VMaXN0IiwicGFnZSIsInBhZ2VTdGFydEluZGV4Iiwic2l6ZVBlclBhZ2UiLCJ2YWx1ZSIsInN0YXRlIiwic2F2ZVRvU3RvcmUiLCJuZXh0UHJvcHMiLCJuZWVkTmV3U3RhdGUiLCJvblBhZ2VDaGFuZ2UiLCJpc0RhdGFDaGFuZ2VkIiwic2V0U3RhdGUiLCJzdG9yZSIsImlzUmVtb3RlUGFnaW5hdGlvbiIsImhhbmRsZVJlbW90ZVBhZ2VDaGFuZ2UiLCJvblNpemVQZXJQYWdlQ2hhbmdlIiwid2l0aEZpcnN0QW5kTGFzdCIsImFsd2F5c1Nob3dBbGxCdG5zIiwiaGlkZVNpemVQZXJQYWdlIiwiaGlkZVBhZ2VMaXN0T25seU9uZVBhZ2UiLCJkYXRhIiwidG90YWxTaXplIiwibGVuZ3RoIiwicGFnaW5hdGlvblNpemUiLCJzaG93VG90YWwiLCJwYWdpbmF0aW9uVG90YWxSZW5kZXJlciIsImZpcnN0UGFnZVRleHQiLCJwcmVQYWdlVGV4dCIsIm5leHRQYWdlVGV4dCIsImxhc3RQYWdlVGV4dCIsInByZVBhZ2VUaXRsZSIsIm5leHRQYWdlVGl0bGUiLCJmaXJzdFBhZ2VUaXRsZSIsImxhc3RQYWdlVGl0bGUiLCJwcm9wVHlwZXMiLCJvYmplY3QiLCJpc1JlcXVpcmVkIiwiUGFnaW5hdGlvbiIsImRlZmF1bHRUb3RhbCIsImZyb20iLCJ0byIsInNpemUiLCJzZXRUb3RhbCIsInRvdGFsIiwiY2xvc2VEcm9wRG93biIsInRvZ2dsZURyb3BEb3duIiwiaW5pdGlhbFN0YXRlIiwiZGF0YVNpemUiLCJ0b3RhbFBhZ2VzIiwiY2FsY3VsYXRlVG90YWxQYWdlIiwibGFzdFBhZ2UiLCJjYWxjdWxhdGVMYXN0UGFnZSIsImRyb3Bkb3duT3BlbiIsInNlbGVjdGVkU2l6ZSIsInBhcnNlSW50IiwibmV3VG90YWxQYWdlcyIsIm5ld0xhc3RQYWdlIiwibmV3UGFnZSIsImJhY2tUb1ByZXZQYWdlIiwib3BlbiIsInBhZ2VzIiwiY2FsY3VsYXRlUGFnZVN0YXR1cyIsImNhbGN1bGF0ZVBhZ2VzIiwiY2FsY3VsYXRlRnJvbVRvIiwicGFnZUxpc3RDbGFzcyIsImNhbGN1bGF0ZVNpemVQZXJQYWdlU3RhdHVzIiwibnVtYmVyIiwiYXJyYXkiLCJmdW5jIiwiYm9vbCIsInN0cmluZyIsImRlZmF1bHRQcm9wcyIsIk1hdGgiLCJjZWlsIiwib2Zmc2V0IiwiYWJzIiwibWluIiwiZW5kUGFnZSIsInN0YXJ0UGFnZSIsIm1heCIsImZsb29yIiwiaSIsInB1c2giLCJpc1N0YXJ0IiwiaXNFbmQiLCJmaWx0ZXIiLCJtYXAiLCJ0aXRsZSIsImFjdGl2ZSIsImRpc2FibGVkIiwiX3NpemVQZXJQYWdlIiwicGFnZVRleHQiLCJ0ZXh0IiwicGFnZU51bWJlciIsIkV4dGVuZEJhc2UiLCJzaXplUGVyUGFnZURlZmF1bHRDbGFzcyIsIlNpemVQZXJQYWdlRHJvcERvd24iLCJoaWRkZW4iLCJvbkNsaWNrIiwib25CbHVyIiwiY2xhc3NOYW1lIiwidmFyaWF0aW9uIiwiYnRuQ29udGV4dHVhbCIsImRyb3BEb3duU3R5bGUiLCJ2aXNpYmlsaXR5IiwiZHJvcGRvd25DbGFzc2VzIiwib3B0aW9uIiwib25lT2YiLCJTaXplUGVyUGFnZU9wdGlvbiIsImUiLCJwcmV2ZW50RGVmYXVsdCIsIlBhZ2luYXRvbkxpc3QiLCJwYWdlUHJvcHMiLCJhcnJheU9mIiwic2hhcGUiLCJvbmVPZlR5cGUiLCJkaXNhYmxlIiwiUGFnZUJ1dHRvbiIsImhhbmRsZUNsaWNrIiwiY2xhc3NlcyIsIlBhZ2luYXRpb25Ub3RhbCIsImdldEJ5Q3VyclBhZ2UiLCJnZXROb3JtYWxpemVkUGFnZSIsImVuZCIsInN0YXJ0IiwicmVzdWx0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FB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RS9DLFVBQU1zRDtBQUQ3RSxHQURzQjtBQUFBLENBQXhCOztBQU1BeUUsZ0JBQWdCdEYsU0FBaEIsR0FBNEI7QUFDMUJLLFFBQU0sb0JBQVUyQixNQUFWLENBQWlCOUIsVUFERztBQUUxQkksTUFBSSxvQkFBVTBCLE1BQVYsQ0FBaUI5QixVQUZLO0FBRzFCVyxZQUFVLG9CQUFVbUIsTUFBVixDQUFpQjlCO0FBSEQsQ0FBNUI7O2tCQU1lb0YsZTs7Ozs7Ozs7Ozs7O0FDZlIsSUFBTUMsd0NBQWdCLFNBQWhCQSxhQUFnQixDQUFDN0csS0FBRCxFQUFRVixjQUFSLEVBQTJCO0FBQ3RELE1BQU02QyxXQUFXbkMsTUFBTVEsSUFBTixDQUFXRSxNQUE1QjtBQUNBLE1BQUksQ0FBQ3lCLFFBQUwsRUFBZSxPQUFPLEVBQVA7QUFDZixNQUFNMkUsb0JBQW9CLFNBQXBCQSxpQkFBb0IsR0FBTTtBQUM5QixRQUFNaEQsU0FBU0YsS0FBS0csR0FBTCxDQUFTLElBQUl6RSxjQUFiLENBQWY7QUFDQSxXQUFPVSxNQUFNWCxJQUFOLEdBQWF5RSxNQUFwQjtBQUNELEdBSEQ7QUFJQSxNQUFNaUQsTUFBT0Qsc0JBQXNCOUcsTUFBTVQsV0FBN0IsR0FBNEMsQ0FBeEQ7QUFDQSxNQUFNeUgsUUFBUUQsT0FBTy9HLE1BQU1ULFdBQU4sR0FBb0IsQ0FBM0IsQ0FBZDs7QUFFQSxNQUFNMEgsU0FBUyxFQUFmO0FBQ0EsT0FBSyxJQUFJNUMsSUFBSTJDLEtBQWIsRUFBb0IzQyxLQUFLMEMsR0FBekIsRUFBOEIxQyxLQUFLLENBQW5DLEVBQXNDO0FBQ3BDNEMsV0FBTzNDLElBQVAsQ0FBWXRFLE1BQU1RLElBQU4sQ0FBVzZELENBQVgsQ0FBWjtBQUNBLFFBQUlBLElBQUksQ0FBSixLQUFVbEMsUUFBZCxFQUF3QjtBQUN6QjtBQUNELFNBQU84RSxNQUFQO0FBQ0QsQ0FoQk0sQyIsImZpbGUiOiJyZWFjdC1ib290c3RyYXAtdGFibGUyLXBhZ2luYXRvci9kaXN0L3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUmVhY3RCb290c3RyYXBUYWJsZTJQYWdpbmF0b3JcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmVhY3RCb290c3RyYXBUYWJsZTJQYWdpbmF0b3JcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA2MTIyMTBkYjBlZjNkZTdlYjQ5MyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZXhwb3J0IGRlZmF1bHQge1xuICBQQUdJTkFUSU9OX1NJWkU6IDUsXG4gIFBBR0VfU1RBUlRfSU5ERVg6IDEsXG4gIFdpdGhfRklSU1RfQU5EX0xBU1Q6IHRydWUsXG4gIFNIT1dfQUxMX1BBR0VfQlROUzogZmFsc2UsXG4gIFNIT1dfVE9UQUw6IGZhbHNlLFxuICBQQUdJTkFUSU9OX1RPVEFMOiBudWxsLFxuICBGSVJTVF9QQUdFX1RFWFQ6ICc8PCcsXG4gIFBSRV9QQUdFX1RFWFQ6ICc8JyxcbiAgTkVYVF9QQUdFX1RFWFQ6ICc+JyxcbiAgTEFTVF9QQUdFX1RFWFQ6ICc+PicsXG4gIE5FWFRfUEFHRV9USVRMRTogJ25leHQgcGFnZScsXG4gIExBU1RfUEFHRV9USVRMRTogJ2xhc3QgcGFnZScsXG4gIFBSRV9QQUdFX1RJVExFOiAncHJldmlvdXMgcGFnZScsXG4gIEZJUlNUX1BBR0VfVElUTEU6ICdmaXJzdCBwYWdlJyxcbiAgU0laRV9QRVJfUEFHRV9MSVNUOiBbMTAsIDI1LCAzMCwgNTBdLFxuICBISURFX1NJWkVfUEVSX1BBR0U6IGZhbHNlLFxuICBISURFX1BBR0VfTElTVF9PTkxZX09ORV9QQUdFOiBmYWxzZVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9jb25zdC5qcyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCB3cmFwcGVyRmFjdG9yeSBmcm9tICcuL3NyYy93cmFwcGVyJztcblxuZXhwb3J0IGRlZmF1bHQgKG9wdGlvbnMgPSB7fSkgPT4gKHtcbiAgd3JhcHBlckZhY3RvcnksXG4gIG9wdGlvbnNcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1wYWdpbmF0b3IvaW5kZXguanMiLCIvKiBlc2xpbnQgcmVhY3QvcHJvcC10eXBlczogMCAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcbmltcG9ydCBQYWdpbmF0aW9uIGZyb20gJy4vcGFnaW5hdGlvbic7XG5pbXBvcnQgeyBnZXRCeUN1cnJQYWdlIH0gZnJvbSAnLi9wYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgKEJhc2UsIHtcbiAgcmVtb3RlUmVzb2x2ZXJcbn0pID0+XG4gIGNsYXNzIFBhZ2luYXRpb25XcmFwcGVyIGV4dGVuZHMgcmVtb3RlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5oYW5kbGVDaGFuZ2VQYWdlID0gdGhpcy5oYW5kbGVDaGFuZ2VQYWdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmhhbmRsZUNoYW5nZVNpemVQZXJQYWdlID0gdGhpcy5oYW5kbGVDaGFuZ2VTaXplUGVyUGFnZS5iaW5kKHRoaXMpO1xuXG4gICAgICBsZXQgY3VyclBhZ2U7XG4gICAgICBsZXQgY3VyclNpemVQZXJQYWdlO1xuICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBwcm9wcy5wYWdpbmF0aW9uO1xuICAgICAgY29uc3Qgc2l6ZVBlclBhZ2VMaXN0ID0gb3B0aW9ucy5zaXplUGVyUGFnZUxpc3QgfHwgQ29uc3QuU0laRV9QRVJfUEFHRV9MSVNUO1xuXG4gICAgICAvLyBpbml0aWFsaXplIGN1cnJlbnQgcGFnZVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGN1cnJQYWdlID0gb3B0aW9ucy5wYWdlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wYWdlU3RhcnRJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3VyclBhZ2UgPSBvcHRpb25zLnBhZ2VTdGFydEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyclBhZ2UgPSBDb25zdC5QQUdFX1NUQVJUX0lOREVYO1xuICAgICAgfVxuXG4gICAgICAvLyBpbml0aWFsaXplIGN1cnJlbnQgc2l6ZVBlclBhZ2VcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplUGVyUGFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3VyclNpemVQZXJQYWdlID0gb3B0aW9ucy5zaXplUGVyUGFnZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNpemVQZXJQYWdlTGlzdFswXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY3VyclNpemVQZXJQYWdlID0gc2l6ZVBlclBhZ2VMaXN0WzBdLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyclNpemVQZXJQYWdlID0gc2l6ZVBlclBhZ2VMaXN0WzBdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0geyBjdXJyUGFnZSwgY3VyclNpemVQZXJQYWdlIH07XG4gICAgICB0aGlzLnNhdmVUb1N0b3JlKGN1cnJQYWdlLCBjdXJyU2l6ZVBlclBhZ2UpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICBsZXQgbmVlZE5ld1N0YXRlID0gZmFsc2U7XG4gICAgICBsZXQgeyBjdXJyUGFnZSwgY3VyclNpemVQZXJQYWdlIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgeyBwYWdlLCBzaXplUGVyUGFnZSwgcGFnZVN0YXJ0SW5kZXgsIG9uUGFnZUNoYW5nZSB9ID0gbmV4dFByb3BzLnBhZ2luYXRpb24ub3B0aW9ucztcblxuICAgICAgaWYgKHR5cGVvZiBwYWdlICE9PSAndW5kZWZpbmVkJyAmJiBjdXJyUGFnZSAhPT0gcGFnZSkgeyAvLyB1c2VyIGRlZmluZWQgcGFnZVxuICAgICAgICBjdXJyUGFnZSA9IHBhZ2U7XG4gICAgICAgIG5lZWROZXdTdGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy5pc0RhdGFDaGFuZ2VkKSB7XG4gICAgICAgIG5lZWROZXdTdGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY3VyclBhZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGN1cnJQYWdlID0gdHlwZW9mIHBhZ2VTdGFydEluZGV4ICE9PSAndW5kZWZpbmVkJyA/IHBhZ2VTdGFydEluZGV4IDogQ29uc3QuUEFHRV9TVEFSVF9JTkRFWDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzaXplUGVyUGFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3VyclNpemVQZXJQYWdlID0gc2l6ZVBlclBhZ2U7XG4gICAgICAgIG5lZWROZXdTdGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2F2ZVRvU3RvcmUoY3VyclBhZ2UsIGN1cnJTaXplUGVyUGFnZSk7XG5cbiAgICAgIGlmIChuZWVkTmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKG9uUGFnZUNoYW5nZSkge1xuICAgICAgICAgIG9uUGFnZUNoYW5nZShjdXJyUGFnZSwgY3VyclNpemVQZXJQYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGN1cnJQYWdlLCBjdXJyU2l6ZVBlclBhZ2UgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNhdmVUb1N0b3JlKHBhZ2UsIHNpemVQZXJQYWdlKSB7XG4gICAgICB0aGlzLnByb3BzLnN0b3JlLnBhZ2UgPSBwYWdlO1xuICAgICAgdGhpcy5wcm9wcy5zdG9yZS5zaXplUGVyUGFnZSA9IHNpemVQZXJQYWdlO1xuICAgIH1cblxuICAgIGhhbmRsZUNoYW5nZVBhZ2UoY3VyclBhZ2UpIHtcbiAgICAgIGNvbnN0IHsgY3VyclNpemVQZXJQYWdlIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgeyBwYWdpbmF0aW9uOiB7IG9wdGlvbnMgfSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHRoaXMuc2F2ZVRvU3RvcmUoY3VyclBhZ2UsIGN1cnJTaXplUGVyUGFnZSk7XG5cbiAgICAgIGlmIChvcHRpb25zLm9uUGFnZUNoYW5nZSkge1xuICAgICAgICBvcHRpb25zLm9uUGFnZUNoYW5nZShjdXJyUGFnZSwgY3VyclNpemVQZXJQYWdlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVtb3RlUGFnZUNoYW5nZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGN1cnJQYWdlIH0pKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDaGFuZ2VTaXplUGVyUGFnZShjdXJyU2l6ZVBlclBhZ2UsIGN1cnJQYWdlKSB7XG4gICAgICBjb25zdCB7IHBhZ2luYXRpb246IHsgb3B0aW9ucyB9IH0gPSB0aGlzLnByb3BzO1xuICAgICAgdGhpcy5zYXZlVG9TdG9yZShjdXJyUGFnZSwgY3VyclNpemVQZXJQYWdlKTtcblxuICAgICAgaWYgKG9wdGlvbnMub25TaXplUGVyUGFnZUNoYW5nZSkge1xuICAgICAgICBvcHRpb25zLm9uU2l6ZVBlclBhZ2VDaGFuZ2UoY3VyclNpemVQZXJQYWdlLCBjdXJyUGFnZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1JlbW90ZVBhZ2luYXRpb24oKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVJlbW90ZVBhZ2VDaGFuZ2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICBjdXJyUGFnZSxcbiAgICAgICAgY3VyclNpemVQZXJQYWdlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyBwYWdpbmF0aW9uOiB7IG9wdGlvbnMgfSwgc3RvcmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IGN1cnJQYWdlLCBjdXJyU2l6ZVBlclBhZ2UgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB3aXRoRmlyc3RBbmRMYXN0ID0gdHlwZW9mIG9wdGlvbnMud2l0aEZpcnN0QW5kTGFzdCA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICBDb25zdC5XaXRoX0ZJUlNUX0FORF9MQVNUIDogb3B0aW9ucy53aXRoRmlyc3RBbmRMYXN0O1xuICAgICAgY29uc3QgYWx3YXlzU2hvd0FsbEJ0bnMgPSB0eXBlb2Ygb3B0aW9ucy5hbHdheXNTaG93QWxsQnRucyA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICBDb25zdC5TSE9XX0FMTF9QQUdFX0JUTlMgOiBvcHRpb25zLmFsd2F5c1Nob3dBbGxCdG5zO1xuICAgICAgY29uc3QgaGlkZVNpemVQZXJQYWdlID0gdHlwZW9mIG9wdGlvbnMuaGlkZVNpemVQZXJQYWdlID09PSAndW5kZWZpbmVkJyA/XG4gICAgICAgIENvbnN0LkhJREVfU0laRV9QRVJfUEFHRSA6IG9wdGlvbnMuaGlkZVNpemVQZXJQYWdlO1xuICAgICAgY29uc3QgaGlkZVBhZ2VMaXN0T25seU9uZVBhZ2UgPSB0eXBlb2Ygb3B0aW9ucy5oaWRlUGFnZUxpc3RPbmx5T25lUGFnZSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICBDb25zdC5ISURFX1BBR0VfTElTVF9PTkxZX09ORV9QQUdFIDogb3B0aW9ucy5oaWRlUGFnZUxpc3RPbmx5T25lUGFnZTtcbiAgICAgIGNvbnN0IHBhZ2VTdGFydEluZGV4ID0gdHlwZW9mIG9wdGlvbnMucGFnZVN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgQ29uc3QuUEFHRV9TVEFSVF9JTkRFWCA6IG9wdGlvbnMucGFnZVN0YXJ0SW5kZXg7XG5cbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpID9cbiAgICAgICAgdGhpcy5wcm9wcy5kYXRhIDpcbiAgICAgICAgZ2V0QnlDdXJyUGFnZShzdG9yZSwgcGFnZVN0YXJ0SW5kZXgpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICA8QmFzZSBrZXk9XCJ0YWJsZVwiIHsgLi4udGhpcy5wcm9wcyB9IGRhdGE9eyBkYXRhIH0gLz4sXG4gICAgICAgIDxQYWdpbmF0aW9uXG4gICAgICAgICAga2V5PVwicGFnaW5hdGlvblwiXG4gICAgICAgICAgZGF0YVNpemU9eyBvcHRpb25zLnRvdGFsU2l6ZSB8fCBzdG9yZS5kYXRhLmxlbmd0aCB9XG4gICAgICAgICAgY3VyclBhZ2U9eyBjdXJyUGFnZSB9XG4gICAgICAgICAgY3VyclNpemVQZXJQYWdlPXsgY3VyclNpemVQZXJQYWdlIH1cbiAgICAgICAgICBvblBhZ2VDaGFuZ2U9eyB0aGlzLmhhbmRsZUNoYW5nZVBhZ2UgfVxuICAgICAgICAgIG9uU2l6ZVBlclBhZ2VDaGFuZ2U9eyB0aGlzLmhhbmRsZUNoYW5nZVNpemVQZXJQYWdlIH1cbiAgICAgICAgICBzaXplUGVyUGFnZUxpc3Q9eyBvcHRpb25zLnNpemVQZXJQYWdlTGlzdCB8fCBDb25zdC5TSVpFX1BFUl9QQUdFX0xJU1QgfVxuICAgICAgICAgIHBhZ2luYXRpb25TaXplPXsgb3B0aW9ucy5wYWdpbmF0aW9uU2l6ZSB8fCBDb25zdC5QQUdJTkFUSU9OX1NJWkUgfVxuICAgICAgICAgIHBhZ2VTdGFydEluZGV4PXsgcGFnZVN0YXJ0SW5kZXggfVxuICAgICAgICAgIHdpdGhGaXJzdEFuZExhc3Q9eyB3aXRoRmlyc3RBbmRMYXN0IH1cbiAgICAgICAgICBhbHdheXNTaG93QWxsQnRucz17IGFsd2F5c1Nob3dBbGxCdG5zIH1cbiAgICAgICAgICBoaWRlU2l6ZVBlclBhZ2U9eyBoaWRlU2l6ZVBlclBhZ2UgfVxuICAgICAgICAgIGhpZGVQYWdlTGlzdE9ubHlPbmVQYWdlPXsgaGlkZVBhZ2VMaXN0T25seU9uZVBhZ2UgfVxuICAgICAgICAgIHNob3dUb3RhbD17IG9wdGlvbnMuc2hvd1RvdGFsIH1cbiAgICAgICAgICBwYWdpbmF0aW9uVG90YWxSZW5kZXJlcj17IG9wdGlvbnMucGFnaW5hdGlvblRvdGFsUmVuZGVyZXIgfVxuICAgICAgICAgIGZpcnN0UGFnZVRleHQ9eyBvcHRpb25zLmZpcnN0UGFnZVRleHQgfHwgQ29uc3QuRklSU1RfUEFHRV9URVhUIH1cbiAgICAgICAgICBwcmVQYWdlVGV4dD17IG9wdGlvbnMucHJlUGFnZVRleHQgfHwgQ29uc3QuUFJFX1BBR0VfVEVYVCB9XG4gICAgICAgICAgbmV4dFBhZ2VUZXh0PXsgb3B0aW9ucy5uZXh0UGFnZVRleHQgfHwgQ29uc3QuTkVYVF9QQUdFX1RFWFQgfVxuICAgICAgICAgIGxhc3RQYWdlVGV4dD17IG9wdGlvbnMubGFzdFBhZ2VUZXh0IHx8IENvbnN0LkxBU1RfUEFHRV9URVhUIH1cbiAgICAgICAgICBwcmVQYWdlVGl0bGU9eyBvcHRpb25zLnByZVBhZ2VUaXRsZSB8fCBDb25zdC5QUkVfUEFHRV9USVRMRSB9XG4gICAgICAgICAgbmV4dFBhZ2VUaXRsZT17IG9wdGlvbnMubmV4dFBhZ2VUaXRsZSB8fCBDb25zdC5ORVhUX1BBR0VfVElUTEUgfVxuICAgICAgICAgIGZpcnN0UGFnZVRpdGxlPXsgb3B0aW9ucy5maXJzdFBhZ2VUaXRsZSB8fCBDb25zdC5GSVJTVF9QQUdFX1RJVExFIH1cbiAgICAgICAgICBsYXN0UGFnZVRpdGxlPXsgb3B0aW9ucy5sYXN0UGFnZVRpdGxlIHx8IENvbnN0LkxBU1RfUEFHRV9USVRMRSB9XG4gICAgICAgIC8+XG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy93cmFwcGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuLyogZXNsaW50IGFycm93LWJvZHktc3R5bGU6IDAgKi9cbmltcG9ydCBjcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHBhZ2VSZXNvbHZlciBmcm9tICcuL3BhZ2UtcmVzb2x2ZXInO1xuaW1wb3J0IFNpemVQZXJQYWdlRHJvcERvd24gZnJvbSAnLi9zaXplLXBlci1wYWdlLWRyb3Bkb3duJztcbmltcG9ydCBQYWdpbmF0aW9uTGlzdCBmcm9tICcuL3BhZ2luYXRpb24tbGlzdCc7XG5pbXBvcnQgUGFnaW5hdGlvblRvdGFsIGZyb20gJy4vcGFnaW5hdGlvbi10b3RhbCc7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdCc7XG5cbmNsYXNzIFBhZ2luYXRpb24gZXh0ZW5kcyBwYWdlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuY2xvc2VEcm9wRG93biA9IHRoaXMuY2xvc2VEcm9wRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMudG9nZ2xlRHJvcERvd24gPSB0aGlzLnRvZ2dsZURyb3BEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDaGFuZ2VQYWdlID0gdGhpcy5oYW5kbGVDaGFuZ2VQYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDaGFuZ2VTaXplUGVyUGFnZSA9IHRoaXMuaGFuZGxlQ2hhbmdlU2l6ZVBlclBhZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5pbml0aWFsU3RhdGUoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgY29uc3QgeyBkYXRhU2l6ZSwgY3VyclNpemVQZXJQYWdlIH0gPSBuZXh0UHJvcHM7XG4gICAgaWYgKGN1cnJTaXplUGVyUGFnZSAhPT0gdGhpcy5wcm9wcy5jdXJyU2l6ZVBlclBhZ2UgfHwgZGF0YVNpemUgIT09IHRoaXMucHJvcHMuZGF0YVNpemUpIHtcbiAgICAgIGNvbnN0IHRvdGFsUGFnZXMgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsUGFnZShjdXJyU2l6ZVBlclBhZ2UsIGRhdGFTaXplKTtcbiAgICAgIGNvbnN0IGxhc3RQYWdlID0gdGhpcy5jYWxjdWxhdGVMYXN0UGFnZSh0b3RhbFBhZ2VzKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyB0b3RhbFBhZ2VzLCBsYXN0UGFnZSB9KTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVEcm9wRG93bigpIHtcbiAgICBjb25zdCBkcm9wZG93bk9wZW4gPSAhdGhpcy5zdGF0ZS5kcm9wZG93bk9wZW47XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiB7XG4gICAgICByZXR1cm4geyBkcm9wZG93bk9wZW4gfTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsb3NlRHJvcERvd24oKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiB7XG4gICAgICByZXR1cm4geyBkcm9wZG93bk9wZW46IGZhbHNlIH07XG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVDaGFuZ2VTaXplUGVyUGFnZShzaXplUGVyUGFnZSkge1xuICAgIGNvbnN0IHsgY3VyclNpemVQZXJQYWdlLCBvblNpemVQZXJQYWdlQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHNlbGVjdGVkU2l6ZSA9IHR5cGVvZiBzaXplUGVyUGFnZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludChzaXplUGVyUGFnZSwgMTApIDogc2l6ZVBlclBhZ2U7XG4gICAgbGV0IHsgY3VyclBhZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHNlbGVjdGVkU2l6ZSAhPT0gY3VyclNpemVQZXJQYWdlKSB7XG4gICAgICBjb25zdCBuZXdUb3RhbFBhZ2VzID0gdGhpcy5jYWxjdWxhdGVUb3RhbFBhZ2Uoc2VsZWN0ZWRTaXplKTtcbiAgICAgIGNvbnN0IG5ld0xhc3RQYWdlID0gdGhpcy5jYWxjdWxhdGVMYXN0UGFnZShuZXdUb3RhbFBhZ2VzKTtcbiAgICAgIGlmIChjdXJyUGFnZSA+IG5ld0xhc3RQYWdlKSBjdXJyUGFnZSA9IG5ld0xhc3RQYWdlO1xuICAgICAgb25TaXplUGVyUGFnZUNoYW5nZShzZWxlY3RlZFNpemUsIGN1cnJQYWdlKTtcbiAgICB9XG4gICAgdGhpcy5jbG9zZURyb3BEb3duKCk7XG4gIH1cblxuICBoYW5kbGVDaGFuZ2VQYWdlKG5ld1BhZ2UpIHtcbiAgICBsZXQgcGFnZTtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyUGFnZSxcbiAgICAgIHBhZ2VTdGFydEluZGV4LFxuICAgICAgcHJlUGFnZVRleHQsXG4gICAgICBuZXh0UGFnZVRleHQsXG4gICAgICBsYXN0UGFnZVRleHQsXG4gICAgICBmaXJzdFBhZ2VUZXh0LFxuICAgICAgb25QYWdlQ2hhbmdlXG4gICAgICAvLyBrZWVwU2l6ZVBlclBhZ2VTdGF0ZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgbGFzdFBhZ2UgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAobmV3UGFnZSA9PT0gcHJlUGFnZVRleHQpIHtcbiAgICAgIHBhZ2UgPSB0aGlzLmJhY2tUb1ByZXZQYWdlKCk7XG4gICAgfSBlbHNlIGlmIChuZXdQYWdlID09PSBuZXh0UGFnZVRleHQpIHtcbiAgICAgIHBhZ2UgPSAoY3VyclBhZ2UgKyAxKSA+IGxhc3RQYWdlID8gbGFzdFBhZ2UgOiBjdXJyUGFnZSArIDE7XG4gICAgfSBlbHNlIGlmIChuZXdQYWdlID09PSBsYXN0UGFnZVRleHQpIHtcbiAgICAgIHBhZ2UgPSBsYXN0UGFnZTtcbiAgICB9IGVsc2UgaWYgKG5ld1BhZ2UgPT09IGZpcnN0UGFnZVRleHQpIHtcbiAgICAgIHBhZ2UgPSBwYWdlU3RhcnRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZSA9IHBhcnNlSW50KG5ld1BhZ2UsIDEwKTtcbiAgICB9XG5cbiAgICAvLyBpZiAoa2VlcFNpemVQZXJQYWdlU3RhdGUpIHsgdGhpcy5jbG9zZURyb3BEb3duKCk7IH1cblxuICAgIGlmIChwYWdlICE9PSBjdXJyUGFnZSkge1xuICAgICAgb25QYWdlQ2hhbmdlKHBhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGRlZmF1bHRUb3RhbCA9IChmcm9tLCB0bywgc2l6ZSkgPT4gKFxuICAgIDxQYWdpbmF0aW9uVG90YWxcbiAgICAgIGZyb209eyBmcm9tIH1cbiAgICAgIHRvPXsgdG8gfVxuICAgICAgZGF0YVNpemU9eyBzaXplIH1cbiAgICAvPlxuICApO1xuXG4gIHNldFRvdGFsID0gKGZyb20sIHRvLCBzaXplLCB0b3RhbCkgPT4ge1xuICAgIGlmICh0b3RhbCAmJiAodHlwZW9mIHRvdGFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgcmV0dXJuIHRvdGFsKGZyb20sIHRvLCBzaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0VG90YWwoZnJvbSwgdG8sIHNpemUpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHRvdGFsUGFnZXMsIGxhc3RQYWdlLCBkcm9wZG93bk9wZW46IG9wZW4gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgc2hvd1RvdGFsLFxuICAgICAgZGF0YVNpemUsXG4gICAgICBwYWdpbmF0aW9uVG90YWxSZW5kZXJlcixcbiAgICAgIHNpemVQZXJQYWdlTGlzdCxcbiAgICAgIGN1cnJTaXplUGVyUGFnZSxcbiAgICAgIGhpZGVTaXplUGVyUGFnZSxcbiAgICAgIGhpZGVQYWdlTGlzdE9ubHlPbmVQYWdlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcGFnZXMgPSB0aGlzLmNhbGN1bGF0ZVBhZ2VTdGF0dXModGhpcy5jYWxjdWxhdGVQYWdlcyh0b3RhbFBhZ2VzKSwgbGFzdFBhZ2UpO1xuICAgIGNvbnN0IFtmcm9tLCB0b10gPSB0aGlzLmNhbGN1bGF0ZUZyb21UbygpO1xuICAgIGNvbnN0IHBhZ2VMaXN0Q2xhc3MgPSBjcyhcbiAgICAgICdyZWFjdC1ib290c3RyYXAtdGFibGUtcGFnaW5hdGlvbi1saXN0JyxcbiAgICAgICdjb2wtbWQtNiBjb2wteHMtNiBjb2wtc20tNiBjb2wtbGctNicsIHtcbiAgICAgICAgJ3JlYWN0LWJvb3RzdHJhcC10YWJsZS1wYWdpbmF0aW9uLWxpc3QtaGlkZGVuJzogKGhpZGVQYWdlTGlzdE9ubHlPbmVQYWdlICYmIHRvdGFsUGFnZXMgPT09IDEpXG4gICAgICB9KTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3cgcmVhY3QtYm9vdHN0cmFwLXRhYmxlLXBhZ2luYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtNiBjb2wteHMtNiBjb2wtc20tNiBjb2wtbGctNlwiPlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNpemVQZXJQYWdlTGlzdC5sZW5ndGggPiAxICYmICFoaWRlU2l6ZVBlclBhZ2UgP1xuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgPFNpemVQZXJQYWdlRHJvcERvd25cbiAgICAgICAgICAgICAgICAgIGN1cnJTaXplUGVyUGFnZT17IGAke2N1cnJTaXplUGVyUGFnZX1gIH1cbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM9eyB0aGlzLmNhbGN1bGF0ZVNpemVQZXJQYWdlU3RhdHVzKCkgfVxuICAgICAgICAgICAgICAgICAgb25TaXplUGVyUGFnZUNoYW5nZT17IHRoaXMuaGFuZGxlQ2hhbmdlU2l6ZVBlclBhZ2UgfVxuICAgICAgICAgICAgICAgICAgb25DbGljaz17IHRoaXMudG9nZ2xlRHJvcERvd24gfVxuICAgICAgICAgICAgICAgICAgb25CbHVyPXsgdGhpcy5jbG9zZURyb3BEb3duIH1cbiAgICAgICAgICAgICAgICAgIG9wZW49eyBvcGVuIH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICB7XG4gICAgICAgICAgICBzaG93VG90YWwgP1xuICAgICAgICAgICAgICB0aGlzLnNldFRvdGFsKFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgZGF0YVNpemUsXG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvblRvdGFsUmVuZGVyZXJcbiAgICAgICAgICAgICAgKSA6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17IHBhZ2VMaXN0Q2xhc3MgfT5cbiAgICAgICAgICA8UGFnaW5hdGlvbkxpc3QgcGFnZXM9eyBwYWdlcyB9IG9uUGFnZUNoYW5nZT17IHRoaXMuaGFuZGxlQ2hhbmdlUGFnZSB9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5QYWdpbmF0aW9uLnByb3BUeXBlcyA9IHtcbiAgZGF0YVNpemU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgc2l6ZVBlclBhZ2VMaXN0OiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY3VyclBhZ2U6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY3VyclNpemVQZXJQYWdlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uUGFnZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25TaXplUGVyUGFnZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgcGFnZVN0YXJ0SW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHBhZ2luYXRpb25TaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzaG93VG90YWw6IFByb3BUeXBlcy5ib29sLFxuICBwYWdpbmF0aW9uVG90YWxSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGZpcnN0UGFnZVRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHByZVBhZ2VUZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBuZXh0UGFnZVRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhc3RQYWdlVGV4dDogUHJvcFR5cGVzLnN0cmluZyxcbiAgbmV4dFBhZ2VUaXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgcHJlUGFnZVRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmaXJzdFBhZ2VUaXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFzdFBhZ2VUaXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2l0aEZpcnN0QW5kTGFzdDogUHJvcFR5cGVzLmJvb2wsXG4gIGFsd2F5c1Nob3dBbGxCdG5zOiBQcm9wVHlwZXMuYm9vbCxcbiAgaGlkZVNpemVQZXJQYWdlOiBQcm9wVHlwZXMuYm9vbCxcbiAgaGlkZVBhZ2VMaXN0T25seU9uZVBhZ2U6IFByb3BUeXBlcy5ib29sXG59O1xuXG5QYWdpbmF0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgcGFnZVN0YXJ0SW5kZXg6IENvbnN0LlBBR0VfU1RBUlRfSU5ERVgsXG4gIHBhZ2luYXRpb25TaXplOiBDb25zdC5QQUdJTkFUSU9OX1NJWkUsXG4gIHdpdGhGaXJzdEFuZExhc3Q6IENvbnN0LldpdGhfRklSU1RfQU5EX0xBU1QsXG4gIGFsd2F5c1Nob3dBbGxCdG5zOiBDb25zdC5TSE9XX0FMTF9QQUdFX0JUTlMsXG4gIHNob3dUb3RhbDogQ29uc3QuU0hPV19UT1RBTCxcbiAgcGFnaW5hdGlvblRvdGFsUmVuZGVyZXI6IENvbnN0LlBBR0lOQVRJT05fVE9UQUwsXG4gIGZpcnN0UGFnZVRleHQ6IENvbnN0LkZJUlNUX1BBR0VfVEVYVCxcbiAgcHJlUGFnZVRleHQ6IENvbnN0LlBSRV9QQUdFX1RFWFQsXG4gIG5leHRQYWdlVGV4dDogQ29uc3QuTkVYVF9QQUdFX1RFWFQsXG4gIGxhc3RQYWdlVGV4dDogQ29uc3QuTEFTVF9QQUdFX1RFWFQsXG4gIHNpemVQZXJQYWdlTGlzdDogQ29uc3QuU0laRV9QRVJfUEFHRV9MSVNULFxuICBuZXh0UGFnZVRpdGxlOiBDb25zdC5ORVhUX1BBR0VfVElUTEUsXG4gIHByZVBhZ2VUaXRsZTogQ29uc3QuUFJFX1BBR0VfVElUTEUsXG4gIGZpcnN0UGFnZVRpdGxlOiBDb25zdC5GSVJTVF9QQUdFX1RJVExFLFxuICBsYXN0UGFnZVRpdGxlOiBDb25zdC5MQVNUX1BBR0VfVElUTEUsXG4gIGhpZGVTaXplUGVyUGFnZTogQ29uc3QuSElERV9TSVpFX1BFUl9QQUdFLFxuICBoaWRlUGFnZUxpc3RPbmx5T25lUGFnZTogQ29uc3QuSElERV9QQUdFX0xJU1RfT05MWV9PTkVfUEFHRVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUGFnaW5hdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9wYWdpbmF0aW9uLmpzIiwiLyogZXNsaW50IG5vLW1peGVkLW9wZXJhdG9yczogMCAqL1xuaW1wb3J0IENvbnN0IGZyb20gJy4vY29uc3QnO1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbmRCYXNlID0+XG4gIGNsYXNzIFBhZ2VSZXNvbHZlciBleHRlbmRzIEV4dGVuZEJhc2Uge1xuICAgIGJhY2tUb1ByZXZQYWdlKCkge1xuICAgICAgY29uc3QgeyBjdXJyUGFnZSwgcGFnZVN0YXJ0SW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gKGN1cnJQYWdlIC0gMSkgPCBwYWdlU3RhcnRJbmRleCA/IHBhZ2VTdGFydEluZGV4IDogY3VyclBhZ2UgLSAxO1xuICAgIH1cblxuICAgIGdvVG9OZXh0UGFnZSgpIHtcbiAgICAgIGNvbnN0IHsgY3VyclBhZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IGxhc3RQYWdlIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgcmV0dXJuIChjdXJyUGFnZSArIDEpID4gbGFzdFBhZ2UgPyBsYXN0UGFnZSA6IGN1cnJQYWdlICsgMTtcbiAgICB9XG5cbiAgICBpbml0aWFsU3RhdGUoKSB7XG4gICAgICBjb25zdCB0b3RhbFBhZ2VzID0gdGhpcy5jYWxjdWxhdGVUb3RhbFBhZ2UoKTtcbiAgICAgIGNvbnN0IGxhc3RQYWdlID0gdGhpcy5jYWxjdWxhdGVMYXN0UGFnZSh0b3RhbFBhZ2VzKTtcbiAgICAgIHJldHVybiB7IHRvdGFsUGFnZXMsIGxhc3RQYWdlLCBkcm9wZG93bk9wZW46IGZhbHNlIH07XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlVG90YWxQYWdlKHNpemVQZXJQYWdlID0gdGhpcy5wcm9wcy5jdXJyU2l6ZVBlclBhZ2UsIGRhdGFTaXplID0gdGhpcy5wcm9wcy5kYXRhU2l6ZSkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChkYXRhU2l6ZSAvIHNpemVQZXJQYWdlKTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVMYXN0UGFnZSh0b3RhbFBhZ2VzKSB7XG4gICAgICBjb25zdCB7IHBhZ2VTdGFydEluZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgcmV0dXJuIHBhZ2VTdGFydEluZGV4ICsgdG90YWxQYWdlcyAtIDE7XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlRnJvbVRvKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhU2l6ZSxcbiAgICAgICAgY3VyclBhZ2UsXG4gICAgICAgIGN1cnJTaXplUGVyUGFnZSxcbiAgICAgICAgcGFnZVN0YXJ0SW5kZXhcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5hYnMoQ29uc3QuUEFHRV9TVEFSVF9JTkRFWCAtIHBhZ2VTdGFydEluZGV4KTtcblxuICAgICAgbGV0IGZyb20gPSAoKGN1cnJQYWdlIC0gcGFnZVN0YXJ0SW5kZXgpICogY3VyclNpemVQZXJQYWdlKTtcbiAgICAgIGZyb20gPSBkYXRhU2l6ZSA9PT0gMCA/IDAgOiBmcm9tICsgMTtcbiAgICAgIGxldCB0byA9IE1hdGgubWluKChjdXJyU2l6ZVBlclBhZ2UgKiAoY3VyclBhZ2UgKyBvZmZzZXQpIC0gMSksIGRhdGFTaXplKTtcbiAgICAgIGlmICh0byA+PSBkYXRhU2l6ZSkgdG8gLT0gMTtcblxuICAgICAgcmV0dXJuIFtmcm9tLCB0b107XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlUGFnZXMoXG4gICAgICB0b3RhbFBhZ2VzID0gdGhpcy5zdGF0ZS50b3RhbFBhZ2VzLFxuICAgICAgbGFzdFBhZ2UgPSB0aGlzLnN0YXRlLmxhc3RQYWdlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJQYWdlLFxuICAgICAgICBwYWdpbmF0aW9uU2l6ZSxcbiAgICAgICAgcGFnZVN0YXJ0SW5kZXgsXG4gICAgICAgIHdpdGhGaXJzdEFuZExhc3QsXG4gICAgICAgIGZpcnN0UGFnZVRleHQsXG4gICAgICAgIHByZVBhZ2VUZXh0LFxuICAgICAgICBuZXh0UGFnZVRleHQsXG4gICAgICAgIGxhc3RQYWdlVGV4dCxcbiAgICAgICAgYWx3YXlzU2hvd0FsbEJ0bnNcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBsZXQgcGFnZXM7XG4gICAgICBsZXQgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgICBpZiAoZW5kUGFnZSA8PSAwKSByZXR1cm4gW107XG5cbiAgICAgIGxldCBzdGFydFBhZ2UgPSBNYXRoLm1heChjdXJyUGFnZSAtIE1hdGguZmxvb3IocGFnaW5hdGlvblNpemUgLyAyKSwgcGFnZVN0YXJ0SW5kZXgpO1xuICAgICAgZW5kUGFnZSA9IHN0YXJ0UGFnZSArIHBhZ2luYXRpb25TaXplIC0gMTtcblxuICAgICAgaWYgKGVuZFBhZ2UgPiBsYXN0UGFnZSkge1xuICAgICAgICBlbmRQYWdlID0gbGFzdFBhZ2U7XG4gICAgICAgIHN0YXJ0UGFnZSA9IGVuZFBhZ2UgLSBwYWdpbmF0aW9uU2l6ZSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydFBhZ2UgIT09IHBhZ2VTdGFydEluZGV4ICYmIHRvdGFsUGFnZXMgPiBwYWdpbmF0aW9uU2l6ZSAmJiB3aXRoRmlyc3RBbmRMYXN0KSB7XG4gICAgICAgIHBhZ2VzID0gW2ZpcnN0UGFnZVRleHQsIHByZVBhZ2VUZXh0XTtcbiAgICAgIH0gZWxzZSBpZiAodG90YWxQYWdlcyA+IDEgfHwgYWx3YXlzU2hvd0FsbEJ0bnMpIHtcbiAgICAgICAgcGFnZXMgPSBbcHJlUGFnZVRleHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFnZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0UGFnZTsgaSA8PSBlbmRQYWdlOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPj0gcGFnZVN0YXJ0SW5kZXgpIHBhZ2VzLnB1c2goaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRQYWdlIDw9IGxhc3RQYWdlICYmIHBhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFnZXMucHVzaChuZXh0UGFnZVRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZFBhZ2UgIT09IGxhc3RQYWdlICYmIHdpdGhGaXJzdEFuZExhc3QpIHtcbiAgICAgICAgcGFnZXMucHVzaChsYXN0UGFnZVRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VzO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVBhZ2VTdGF0dXMocGFnZXMgPSBbXSwgbGFzdFBhZ2UgPSB0aGlzLnN0YXRlLmxhc3RQYWdlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJQYWdlLFxuICAgICAgICBwYWdlU3RhcnRJbmRleCxcbiAgICAgICAgZmlyc3RQYWdlVGV4dCxcbiAgICAgICAgcHJlUGFnZVRleHQsXG4gICAgICAgIG5leHRQYWdlVGV4dCxcbiAgICAgICAgbGFzdFBhZ2VUZXh0LFxuICAgICAgICBhbHdheXNTaG93QWxsQnRuc1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCBpc1N0YXJ0ID0gcGFnZSA9PlxuICAgICAgICAoY3VyclBhZ2UgPT09IHBhZ2VTdGFydEluZGV4ICYmIChwYWdlID09PSBmaXJzdFBhZ2VUZXh0IHx8IHBhZ2UgPT09IHByZVBhZ2VUZXh0KSk7XG4gICAgICBjb25zdCBpc0VuZCA9IHBhZ2UgPT5cbiAgICAgICAgKGN1cnJQYWdlID09PSBsYXN0UGFnZSAmJiAocGFnZSA9PT0gbmV4dFBhZ2VUZXh0IHx8IHBhZ2UgPT09IGxhc3RQYWdlVGV4dCkpO1xuXG4gICAgICByZXR1cm4gcGFnZXNcbiAgICAgICAgLmZpbHRlcigocGFnZSkgPT4ge1xuICAgICAgICAgIGlmIChhbHdheXNTaG93QWxsQnRucykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhKGlzU3RhcnQocGFnZSkgfHwgaXNFbmQocGFnZSkpO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKChwYWdlKSA9PiB7XG4gICAgICAgICAgbGV0IHRpdGxlO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHBhZ2UgPT09IGN1cnJQYWdlO1xuICAgICAgICAgIGNvbnN0IGRpc2FibGVkID0gKGlzU3RhcnQocGFnZSkgfHwgaXNFbmQocGFnZSkpO1xuXG4gICAgICAgICAgaWYgKHBhZ2UgPT09IG5leHRQYWdlVGV4dCkge1xuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLnByb3BzLm5leHRQYWdlVGl0bGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYWdlID09PSBwcmVQYWdlVGV4dCkge1xuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLnByb3BzLnByZVBhZ2VUaXRsZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhZ2UgPT09IGZpcnN0UGFnZVRleHQpIHtcbiAgICAgICAgICAgIHRpdGxlID0gdGhpcy5wcm9wcy5maXJzdFBhZ2VUaXRsZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhZ2UgPT09IGxhc3RQYWdlVGV4dCkge1xuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLnByb3BzLmxhc3RQYWdlVGl0bGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlID0gYCR7cGFnZX1gO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IHBhZ2UsIGFjdGl2ZSwgZGlzYWJsZWQsIHRpdGxlIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVNpemVQZXJQYWdlU3RhdHVzKCkge1xuICAgICAgY29uc3QgeyBzaXplUGVyUGFnZUxpc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gc2l6ZVBlclBhZ2VMaXN0Lm1hcCgoX3NpemVQZXJQYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2VUZXh0ID0gX3NpemVQZXJQYWdlLnRleHQgfHwgX3NpemVQZXJQYWdlO1xuICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gX3NpemVQZXJQYWdlLnZhbHVlIHx8IF9zaXplUGVyUGFnZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0ZXh0OiBgJHtwYWdlVGV4dH1gLFxuICAgICAgICAgIHBhZ2U6IHBhZ2VOdW1iZXJcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1wYWdpbmF0b3Ivc3JjL3BhZ2UtcmVzb2x2ZXIuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBTaXplUGVyUGFnZU9wdGlvbiBmcm9tICcuL3NpemUtcGVyLXBhZ2Utb3B0aW9uJztcblxuY29uc3Qgc2l6ZVBlclBhZ2VEZWZhdWx0Q2xhc3MgPSAncmVhY3QtYnMtdGFibGUtc2l6ZVBlclBhZ2UtZHJvcGRvd24nO1xuXG5jb25zdCBTaXplUGVyUGFnZURyb3BEb3duID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGhpZGRlbixcbiAgICBvbkNsaWNrLFxuICAgIG9uQmx1cixcbiAgICBvcHRpb25zLFxuICAgIGNsYXNzTmFtZSxcbiAgICB2YXJpYXRpb24sXG4gICAgYnRuQ29udGV4dHVhbCxcbiAgICBjdXJyU2l6ZVBlclBhZ2UsXG4gICAgb25TaXplUGVyUGFnZUNoYW5nZVxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgZHJvcERvd25TdHlsZSA9IHsgdmlzaWJpbGl0eTogaGlkZGVuID8gJ2hpZGRlbicgOiAndmlzaWJsZScgfTtcbiAgY29uc3QgZHJvcGRvd25DbGFzc2VzID0gY3MoXG4gICAgb3BlbiA/ICdvcGVuIHNob3cnIDogJycsXG4gICAgc2l6ZVBlclBhZ2VEZWZhdWx0Q2xhc3MsXG4gICAgdmFyaWF0aW9uLFxuICAgIGNsYXNzTmFtZSxcbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICBzdHlsZT17IGRyb3BEb3duU3R5bGUgfVxuICAgICAgY2xhc3NOYW1lPXsgZHJvcGRvd25DbGFzc2VzIH1cbiAgICA+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGlkPVwicGFnZURyb3BEb3duXCJcbiAgICAgICAgY2xhc3NOYW1lPXsgYGJ0biAke2J0bkNvbnRleHR1YWx9IGRyb3Bkb3duLXRvZ2dsZWAgfVxuICAgICAgICBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJcbiAgICAgICAgYXJpYS1leHBhbmRlZD17IG9wZW4gfVxuICAgICAgICBvbkNsaWNrPXsgb25DbGljayB9XG4gICAgICAgIG9uQmx1cj17IG9uQmx1ciB9XG4gICAgICA+XG4gICAgICAgIHsgY3VyclNpemVQZXJQYWdlIH1cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAgeyAnICcgfVxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNhcmV0XCIgLz5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8dWwgY2xhc3NOYW1lPVwiZHJvcGRvd24tbWVudVwiIHJvbGU9XCJtZW51XCIgYXJpYS1sYWJlbGxlZGJ5PVwicGFnZURyb3BEb3duXCI+XG4gICAgICAgIHtcbiAgICAgICAgICBvcHRpb25zLm1hcChvcHRpb24gPT4gKFxuICAgICAgICAgICAgPFNpemVQZXJQYWdlT3B0aW9uXG4gICAgICAgICAgICAgIHsgLi4ub3B0aW9uIH1cbiAgICAgICAgICAgICAga2V5PXsgb3B0aW9uLnRleHQgfVxuICAgICAgICAgICAgICBvblNpemVQZXJQYWdlQ2hhbmdlPXsgb25TaXplUGVyUGFnZUNoYW5nZSB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpXG4gICAgICAgIH1cbiAgICAgIDwvdWw+XG4gICAgPC9zcGFuPlxuICApO1xufTtcblxuU2l6ZVBlclBhZ2VEcm9wRG93bi5wcm9wVHlwZXMgPSB7XG4gIGN1cnJTaXplUGVyUGFnZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBvcHRpb25zOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvblNpemVQZXJQYWdlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgaGlkZGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgYnRuQ29udGV4dHVhbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgdmFyaWF0aW9uOiBQcm9wVHlwZXMub25lT2YoWydkcm9wZG93bicsICdkcm9wdXAnXSksXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblNpemVQZXJQYWdlRHJvcERvd24uZGVmYXVsdFByb3BzID0ge1xuICBvcGVuOiBmYWxzZSxcbiAgaGlkZGVuOiBmYWxzZSxcbiAgYnRuQ29udGV4dHVhbDogJ2J0bi1kZWZhdWx0IGJ0bi1zZWNvbmRhcnknLFxuICB2YXJpYXRpb246ICdkcm9wZG93bicsXG4gIGNsYXNzTmFtZTogJydcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU2l6ZVBlclBhZ2VEcm9wRG93bjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9zaXplLXBlci1wYWdlLWRyb3Bkb3duLmpzIiwiLyogZXNsaW50IGpzeC1hMTF5L2hyZWYtbm8taGFzaDogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IFNpemVQZXJQYWdlT3B0aW9uID0gKHtcbiAgdGV4dCxcbiAgcGFnZSxcbiAgb25TaXplUGVyUGFnZUNoYW5nZVxufSkgPT4gKFxuICA8bGkga2V5PXsgdGV4dCB9IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzc05hbWU9XCJkcm9wZG93bi1pdGVtXCI+XG4gICAgPGFcbiAgICAgIGhyZWY9XCIjXCJcbiAgICAgIHRhYkluZGV4PVwiLTFcIlxuICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgIGRhdGEtcGFnZT17IHBhZ2UgfVxuICAgICAgb25Nb3VzZURvd249eyAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uU2l6ZVBlclBhZ2VDaGFuZ2UocGFnZSk7XG4gICAgICB9IH1cbiAgICA+XG4gICAgICB7IHRleHQgfVxuICAgIDwvYT5cbiAgPC9saT5cbik7XG5cblNpemVQZXJQYWdlT3B0aW9uLnByb3BUeXBlcyA9IHtcbiAgdGV4dDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBwYWdlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG9uU2l6ZVBlclBhZ2VDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNpemVQZXJQYWdlT3B0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1wYWdpbmF0b3Ivc3JjL3NpemUtcGVyLXBhZ2Utb3B0aW9uLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCBQYWdlQnV0dG9uIGZyb20gJy4vcGFnZS1idXR0b24nO1xuXG5jb25zdCBQYWdpbmF0b25MaXN0ID0gcHJvcHMgPT4gKFxuICA8dWwgY2xhc3NOYW1lPVwicGFnaW5hdGlvbiByZWFjdC1ib290c3RyYXAtdGFibGUtcGFnZS1idG5zLXVsXCI+XG4gICAge1xuICAgICAgcHJvcHMucGFnZXMubWFwKHBhZ2VQcm9wcyA9PiAoXG4gICAgICAgIDxQYWdlQnV0dG9uXG4gICAgICAgICAga2V5PXsgcGFnZVByb3BzLnBhZ2UgfVxuICAgICAgICAgIHsgLi4ucGFnZVByb3BzIH1cbiAgICAgICAgICBvblBhZ2VDaGFuZ2U9eyBwcm9wcy5vblBhZ2VDaGFuZ2UgfVxuICAgICAgICAvPlxuICAgICAgKSlcbiAgICB9XG4gIDwvdWw+XG4pO1xuXG5QYWdpbmF0b25MaXN0LnByb3BUeXBlcyA9IHtcbiAgcGFnZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gICAgcGFnZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcbiAgfSkpLmlzUmVxdWlyZWQsXG4gIG9uUGFnZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUGFnaW5hdG9uTGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItcGFnaW5hdG9yL3NyYy9wYWdpbmF0aW9uLWxpc3QuanMiLCIvKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG4vKiBlc2xpbnQganN4LWExMXkvaHJlZi1uby1oYXNoOiAwICovXG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgUGFnZUJ1dHRvbiBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBoYW5kbGVDbGljayhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMucHJvcHMub25QYWdlQ2hhbmdlKHRoaXMucHJvcHMucGFnZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZSxcbiAgICAgIHRpdGxlLFxuICAgICAgYWN0aXZlLFxuICAgICAgZGlzYWJsZWRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBjbGFzc2VzID0gY3Moe1xuICAgICAgYWN0aXZlLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICAncGFnZS1pdGVtJzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxsaSBjbGFzc05hbWU9eyBjbGFzc2VzIH0gdGl0bGU9eyB0aXRsZSB9PlxuICAgICAgICA8YSBocmVmPVwiI1wiIG9uQ2xpY2s9eyB0aGlzLmhhbmRsZUNsaWNrIH0gY2xhc3NOYW1lPVwicGFnZS1saW5rXCI+eyBwYWdlIH08L2E+XG4gICAgICA8L2xpPlxuICAgICk7XG4gIH1cbn1cblxuUGFnZUJ1dHRvbi5wcm9wVHlwZXMgPSB7XG4gIG9uUGFnZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgcGFnZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLmlzUmVxdWlyZWQsXG4gIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBQYWdlQnV0dG9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1wYWdpbmF0b3Ivc3JjL3BhZ2UtYnV0dG9uLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IFBhZ2luYXRpb25Ub3RhbCA9IHByb3BzID0+IChcbiAgPHNwYW4gY2xhc3NOYW1lPVwicmVhY3QtYm9vdHN0cmFwLXRhYmxlLXBhZ2luYXRpb24tdG90YWxcIj5cbiAgICAmbmJzcDtTaG93aW5nIHJvd3MgeyBwcm9wcy5mcm9tIH0gdG8mbmJzcDt7IHByb3BzLnRvICsgMSB9IG9mJm5ic3A7eyBwcm9wcy5kYXRhU2l6ZSB9XG4gIDwvc3Bhbj5cbik7XG5cblBhZ2luYXRpb25Ub3RhbC5wcm9wVHlwZXMgPSB7XG4gIGZyb206IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgdG86IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgZGF0YVNpemU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUGFnaW5hdGlvblRvdGFsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1wYWdpbmF0b3Ivc3JjL3BhZ2luYXRpb24tdG90YWwuanMiLCJleHBvcnQgY29uc3QgZ2V0QnlDdXJyUGFnZSA9IChzdG9yZSwgcGFnZVN0YXJ0SW5kZXgpID0+IHtcbiAgY29uc3QgZGF0YVNpemUgPSBzdG9yZS5kYXRhLmxlbmd0aDtcbiAgaWYgKCFkYXRhU2l6ZSkgcmV0dXJuIFtdO1xuICBjb25zdCBnZXROb3JtYWxpemVkUGFnZSA9ICgpID0+IHtcbiAgICBjb25zdCBvZmZzZXQgPSBNYXRoLmFicygxIC0gcGFnZVN0YXJ0SW5kZXgpO1xuICAgIHJldHVybiBzdG9yZS5wYWdlICsgb2Zmc2V0O1xuICB9O1xuICBjb25zdCBlbmQgPSAoZ2V0Tm9ybWFsaXplZFBhZ2UoKSAqIHN0b3JlLnNpemVQZXJQYWdlKSAtIDE7XG4gIGNvbnN0IHN0YXJ0ID0gZW5kIC0gKHN0b3JlLnNpemVQZXJQYWdlIC0gMSk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkgKz0gMSkge1xuICAgIHJlc3VsdC5wdXNoKHN0b3JlLmRhdGFbaV0pO1xuICAgIGlmIChpICsgMSA9PT0gZGF0YVNpemUpIGJyZWFrO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1wYWdpbmF0b3Ivc3JjL3BhZ2UuanMiXSwic291cmNlUm9vdCI6IiJ9
//# sourceMappingURL=react-bootstrap-table2-paginator.js.map